# OMMX Documentation for AI Assistants

## Tutorial Content

### Solve With Ommx Adapter.Md


OMMX provides OMMX Adapter software to enable interoperability with existing mathematical optimization tools. By using OMMX Adapter, you can convert optimization problems expressed in OMMX schemas into formats acceptable to other optimization tools, and convert the resulting data from those tools back into OMMX schemas.

Here, we introduce how to solve a 0-1 Knapsack Problem via OMMX PySCIPOpt Adapter.

## Installing the Required Libraries

First, install OMMX PySCIPOpt Adapter with:

```
pip install ommx-pyscipopt-adapter
```

## Two Steps for Running the Optimization

```{figure} ./assets/solve_with_ommx_adapter_01.png
:alt: Flow for solving 0-1 Knapsack Problem via OMMX PySCIPOpt Adapter

Flow for solving 0-1 Knapsack Problem with OMMX PySCIPOpt Adapter.
```

To solve the 0-1 Knapsack Problem through the OMMX PySCIPOpt Adapter, follow these two steps:

1. Prepare the 0-1 Knapsack problem instance.
2. Run the optimization via OMMX Adapter.

In Step 1, we create an `ommx.v1.Instance` object defined in the OMMX Message Instance schema. There are several ways to generate this object, but in this guide, we'll illustrate how to write it directly using the OMMX Python SDK.

```{tip}
There are four ways to prepare an `ommx.v1.Instance`:
1. Write `ommx.v1.Instance` directly with the OMMX Python SDK.
2. Convert an MPS file to `ommx.v1.Instance` using the OMMX Python SDK.
3. Convert a problem instance from a different optimization tool into `ommx.v1.Instance` using an OMMX Adapter.
4. Export `ommx.v1.Instance` from JijModeling.
```

In Step 2, we convert `ommx.v1.Instance` into a PySCIPOpt `Model` object and run optimization with SCIP. The result is obtained as an `ommx.v1.Solution` object defined by the OMMX Message Solution schema.

### Step 1: Preparing a 0-1 Knapsack Problem Instance

The 0-1 Knapsack problem is formulated as:

$$
\begin{align*}
\mathrm{maximize} \quad & \sum_{i=0}^{N-1} v_i x_i \\
\mathrm{s.t.} \quad & \sum_{i=0}^{n-1} w_i x_i - W \leq 0, \\
& x_{i} \in \{ 0, 1\} 
\end{align*}
$$

We set the following data as parameters for this model.


```python
# Data for 0-1 Knapsack Problem
v = [10, 13, 18, 31, 7, 15]   # Values of each item
w = [11, 25, 20, 35, 10, 33] # Weights of each item
W = 47  # Capacity of the knapsack
N = len(v)  # Total number of items
```

Below is an example code using the OMMX Python SDK to describe this problem instance.


```python
from ommx.v1 import Instance, DecisionVariable, Constraint

# Define decision variables
x = [
    # Define binary variable x_i
    DecisionVariable.binary(
        # Specify the ID of the decision variable
        id=i,
        # Specify the name of the decision variable
        name="x",
        # Specify the subscript of the decision variable
        subscripts=[i],
    )
    # Prepare binary variables for the number of items
    for i in range(N)
]

# Define the objective function
objective = sum(v[i] * x[i] for i in range(N))

# Define the constraint
constraint = sum(w[i] * x[i] for i in range(N)) - W <= 0
# Specify the name of the constraint
constraint.add_name("Weight limit")

# Create an instance
instance = Instance.from_components(
    # Register all decision variables included in the instance
    decision_variables=x,
    # Register the objective function
    objective=objective,
    # Register all constraints
    constraints=[constraint],
    # Specify that it is a maximization problem
    sense=Instance.MAXIMIZE,
)
```

### Step 2: Running Optimization with OMMX Adapter

To optimize the instance prepared in Step 1, we convert it to a PySCIPOpt `Model` and run SCIP optimization via the OMMX PySCIPOpt Adapter.


```python
from ommx_pyscipopt_adapter import OMMXPySCIPOptAdapter

# Obtain an ommx.v1.Solution objection through a PySCIPOpt model.
solution = OMMXPySCIPOptAdapter.solve(instance)
```

The variable `solution` is an `ommx.v1.Solution` object that holds the results returned by SCIP.

## Analyzing the Results

From the `solution` in Step 2, we can check:

- The optimal solution (which items to pick to maximize total value)
- The optimal value (maximum total value)
- The status of constraints (how close we are to the knapsack weight limit)

We can do this with various properties in the `ommx.v1.Solution` class.

### Analyzing the Optimal Solution

The `decision_variables` property returns a `pandas.DataFrame` containing information on each variable, such as ID, type, name, and value:



```python
solution.decision_variables
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>kind</th>
      <th>lower</th>
      <th>upper</th>
      <th>name</th>
      <th>subscripts</th>
      <th>description</th>
      <th>substituted_value</th>
      <th>value</th>
    </tr>
    <tr>
      <th>id</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>binary</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>x</td>
      <td>[0]</td>
      <td>&lt;NA&gt;</td>
      <td>&lt;NA&gt;</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>binary</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>x</td>
      <td>[1]</td>
      <td>&lt;NA&gt;</td>
      <td>&lt;NA&gt;</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>binary</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>x</td>
      <td>[2]</td>
      <td>&lt;NA&gt;</td>
      <td>&lt;NA&gt;</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>binary</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>x</td>
      <td>[3]</td>
      <td>&lt;NA&gt;</td>
      <td>&lt;NA&gt;</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>binary</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>x</td>
      <td>[4]</td>
      <td>&lt;NA&gt;</td>
      <td>&lt;NA&gt;</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>binary</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>x</td>
      <td>[5]</td>
      <td>&lt;NA&gt;</td>
      <td>&lt;NA&gt;</td>
      <td>0.0</td>
    </tr>
  </tbody>
</table>
</div>



Using this `pandas.DataFrame`, for example, you can easily create a table in pandas that shows which items are included in the knapsack.


```python
import pandas as pd

df = solution.decision_variables
pd.DataFrame.from_dict(
    {
        "Item number": df.index,
        "Include in knapsack?": df["value"].apply(lambda x: "Include" if x == 1.0 else "Exclude"),
    }
)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Item number</th>
      <th>Include in knapsack?</th>
    </tr>
    <tr>
      <th>id</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>Include</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>Exclude</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>Exclude</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>Include</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>Exclude</td>
    </tr>
    <tr>
      <th>5</th>
      <td>5</td>
      <td>Exclude</td>
    </tr>
  </tbody>
</table>
</div>



From this analysis, we see that choosing items 0 and 3 maximizes the total value while satisfying the knapsack’s weight constraint.

### Analyzing the Optimal Value

`objective` stores the best value found. In this case, it should match the sum of items 0 and 3.


```python
import numpy as np
# The expected value is the sum of the values of items 0 and 3
expected = v[0] + v[3]
assert np.isclose(solution.objective, expected)
```

### Analyzing Constraints

The `constraints` property returns a `pandas.DataFrame` that includes details about each constraint’s equality or inequality, its left-hand-side value (`"value"`), name, and more.


```python
solution.constraints
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>equality</th>
      <th>value</th>
      <th>used_ids</th>
      <th>name</th>
      <th>subscripts</th>
      <th>description</th>
      <th>dual_variable</th>
      <th>removed_reason</th>
    </tr>
    <tr>
      <th>id</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>&lt;=0</td>
      <td>-1.0</td>
      <td>{0, 1, 2, 3, 4, 5}</td>
      <td>Weight limit</td>
      <td>[]</td>
      <td>&lt;NA&gt;</td>
      <td>&lt;NA&gt;</td>
      <td>&lt;NA&gt;</td>
    </tr>
  </tbody>
</table>
</div>



Specifically, The `"value"` is helpful for understanding how much slack remains in each constraint. Here, item 0 weighs $11$, item 3 weighs $35$, and the knapsack’s capacity is $47$. Therefore, for the weight constraint 

$$
\begin{align*}
\sum_{i=0}^{n-1} w_i x_i - W \leq 0
\end{align*}
$$
the left-hand side "value" is $-1$, indicating there is exactly 1 unit of slack under the capacity.


### Tsp Sampling With Openjij Adapter.Md


Here, we explain how to convert a problem to QUBO and perform sampling using the Traveling Salesman Problem as an example.

```{figure} ./assets/taraimawashi_businessman.png
[Illustration of a man in a suit](https://www.irasutoya.com/2017/03/blog-post_739.html)
```

The Traveling Salesman Problem (TSP) is about finding a route for a salesman to visit multiple cities in sequence. Given the travel costs between cities, we seek to find the path that minimizes the total cost. Let's consider the following city arrangement:


```python
# From ulysses16.tsp in TSPLIB
ulysses16_points = [
    (38.24, 20.42),
    (39.57, 26.15),
    (40.56, 25.32),
    (36.26, 23.12),
    (33.48, 10.54),
    (37.56, 12.19),
    (38.42, 13.11),
    (37.52, 20.44),
    (41.23, 9.10),
    (41.17, 13.05),
    (36.08, -5.21),
    (38.47, 15.13),
    (38.15, 15.35),
    (37.51, 15.17),
    (35.49, 14.32),
    (39.36, 19.56),
]
```

Let's plot the locations of the cities.


```python
%matplotlib inline
from matplotlib import pyplot as plt

x_coords, y_coords = zip(*ulysses16_points)
plt.scatter(x_coords, y_coords)
plt.xlabel('X Coordinate')
plt.ylabel('Y Coordinate')
plt.title('Ulysses16 Points')
plt.show()
```


    
![png](/tmp/tmp7_xxqc3e/markdown/tsp_sampling_with_openjij_adapter_3_0.png)
    


Let's consider distance as the cost. We'll calculate the distance $d(i, j)$ between city $i$ and city $j$.


```python
def distance(x, y):
    return ((x[0] - y[0])**2 + (x[1] - y[1])**2)**0.5

# Number of cities
N = len(ulysses16_points)
# Distance between each pair of cities
d = [[distance(ulysses16_points[i], ulysses16_points[j]) for i in range(N)] for j in range(N)]
```

Using this, we can formulate TSP as follows. First, let's represent whether we are at city $i$ at time $t$ with a binary variable $x_{t, i}$. Then, we seek $x_{t, i}$ that satisfies the following constraints. The distance traveled by the salesman is given by:

$$
\sum_{t=0}^{N-1} \sum_{i, j = 0}^{N-1} d(i, j) x_{t, i} x_{(t+1 \% N), j}
$$

However, $x_{t, i}$ cannot be chosen freely and must satisfy two constraints: at each time $t$, the salesman can only be in one city, and each city must be visited exactly once:

$$
\sum_{i=0}^{N-1} x_{t, i} = 1, \quad \sum_{t=0}^{N-1} x_{t, i} = 1
$$

Combining these, TSP can be formulated as a constrained optimization problem:

$$
\begin{align*}
\min \quad & \sum_{t=0}^{N-1} \sum_{i, j = 0}^{N-1} d(i, j) x_{t, i} x_{(t+1 \% N), j} \\
\text{s.t.} \quad & \sum_{i=0}^{N-1} x_{t, i} = 1 \quad (\forall t = 0, \ldots, N-1) \\
\quad & \sum_{t=0}^{N-1} x_{t, i} = 1 \quad (\forall i = 0, \ldots, N-1)
\end{align*}
$$

The corresponding `ommx.v1.Instance` can be created as follows:


```python
from ommx.v1 import DecisionVariable, Instance

x = [[
        DecisionVariable.binary(
            i + N * t,  # Decision variable ID
            name="x",           # Name of the decision variable, used when extracting solutions
            subscripts=[t, i])  # Subscripts of the decision variable, used when extracting solutions
        for i in range(N)
    ]
    for t in range(N)
]

objective = sum(
    d[i][j] * x[t][i] * x[(t+1) % N][j]
    for i in range(N)
    for j in range(N)
    for t in range(N)
)
place_constraint = [
    (sum(x[t][i] for i in range(N)) == 1)
        .set_id(t)  # type: ignore
        .add_name("place")
        .add_subscripts([t])
    for t in range(N)
]
time_constraint = [
    (sum(x[t][i] for t in range(N)) == 1)
        .set_id(i + N)  # type: ignore
        .add_name("time")
        .add_subscripts([i])
    for i in range(N)
]

instance = Instance.from_components(
    decision_variables=[x[t][i] for i in range(N) for t in range(N)],
    objective=objective,
    constraints=place_constraint + time_constraint,
    sense=Instance.MINIMIZE
)
```

The variable names and subscripts added to `DecisionVariable.binary` during creation will be used later when interpreting the obtained samples.

## Converting to QUBO

Many samplers, including OpenJij, operate by generating samples that minimize the objective function described in QUBO (Quadratic Unconstrained Binary Optimization) without constraints. The Traveling Salesman Problem formulated above has all binary variables but includes constraints, making it constrained. Therefore, we convert it to an unconstrained problem by embedding the constraints into the objective function using the penalty method. OMMX's [`Instance.uniform_penalty_method`](https://jij-inc.github.io/ommx/python/ommx/autoapi/ommx/v1/index.html#ommx.v1.Instance.uniform_penalty_method) converts a problem with equality constraints

$$
\begin{align*}
\min \quad &f(x) \\
\text{s.t.} \quad &g_i(x) = 0 \quad (\forall i)
\end{align*}
$$

into an unconstrained problem with a single parameter $\lambda$:

$$
\min \quad f(x) + \lambda \sum_i g_i(x)^2
$$

If you want to specify weight parameters for each constraint, you can use [`Instance.penalty_method`](https://jij-inc.github.io/ommx/python/ommx/autoapi/ommx/v1/index.html#ommx.v1.Instance.penalty_method) to convert it into

$$
\min \quad f(x) + \sum_i \lambda_i g_i(x)^2
$$

OMMX's `Instance.penalty_method` allows for specifying individual weight parameters for each constraint.


```python
parametric_qubo = instance.uniform_penalty_method()
```

Since this has parameters that are not decision variables, it becomes a `ommx.v1.ParametricInstance` instead of `ommx.v1.Instance`, which corresponds to the following parameterized QUBO:

$$
\min \quad \sum_{t=0}^{N-1} \sum_{i, j = 0}^{N-1} d(i, j) x_{t, i} x_{(t+1 \% N), j}
+ \lambda \left[ \sum_{t=0}^{N-1} \left(\sum_{i=0}^{N-1} x_{t, i} - 1\right)^2
+ \sum_{i=0}^{N-1} \left(\sum_{t=0}^{N-1} x_{t, i} - 1\right)^2 \right]
$$

You can check the parameters of the `ParametricInstance` using the `parameters` property.


```python
parametric_qubo.parameters
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>subscripts</th>
      <th>description</th>
    </tr>
    <tr>
      <th>id</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>256</th>
      <td>uniform_penalty_weight</td>
      <td>[]</td>
      <td>&lt;NA&gt;</td>
    </tr>
  </tbody>
</table>
</div>



As explained above, `uniform_penalty_method` has a single penalty weight parameter, so there is only one parameter. To fix this parameter to $\lambda = 20.0$, use `with_parameters` to specify the parameter. This function takes a dictionary `dict[int, float]` that maps parameter IDs to values.


```python
weight = parametric_qubo.get_parameters()[0]
qubo = parametric_qubo.with_parameters({weight.id: 20.0})
```

The resulting `qubo` now has all parameters substituted, so it is an `ommx.v1.Instance` instead of an `ommx.v1.ParametricInstance`. Additionally, it is an unconstrained optimization problem without any constraints.


```python
assert qubo.get_constraints() == []
```

However, this `qubo` instance retains the information of the original constraints as `removed_constraints`. This information is used to verify whether the samples obtained from QUBO satisfy the original problem's constraints. Converting to QUBO is an extreme example, but it is common for users to preprocess their mathematical models in such a way that the original constraints become unnecessary before passing them to a solver. Even in such cases, users are interested in the original constraints they input, so `ommx.v1.Instance` includes a mechanism to retain this information.


```python
qubo.removed_constraints.head(2)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>equality</th>
      <th>type</th>
      <th>used_ids</th>
      <th>name</th>
      <th>subscripts</th>
      <th>description</th>
      <th>removed_reason</th>
    </tr>
    <tr>
      <th>id</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>=0</td>
      <td>linear</td>
      <td>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,...</td>
      <td>place</td>
      <td>[0]</td>
      <td>&lt;NA&gt;</td>
      <td>uniform_penalty_method</td>
    </tr>
    <tr>
      <th>1</th>
      <td>=0</td>
      <td>linear</td>
      <td>{16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 2...</td>
      <td>place</td>
      <td>[1]</td>
      <td>&lt;NA&gt;</td>
      <td>uniform_penalty_method</td>
    </tr>
  </tbody>
</table>
</div>



Note that the objective function of this `qubo` instance differs from the original problem's objective function. The `objective` value in subsequent processes refers to the value of this new objective function (commonly known as the energy value).


## Sampling with OpenJij

To sample the QUBO described by `ommx.v1.Instance` using OpenJij, use the `ommx-openjij-adapter`.


```python
import ommx_openjij_adapter as adapter

samples = adapter.sample_qubo_sa(qubo, num_reads=16)
sample_set = qubo.evaluate_samples(samples)
sample_set.summary
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>objective</th>
      <th>feasible</th>
    </tr>
    <tr>
      <th>sample_id</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>84.623513</td>
      <td>True</td>
    </tr>
    <tr>
      <th>4</th>
      <td>94.033786</td>
      <td>True</td>
    </tr>
    <tr>
      <th>15</th>
      <td>99.704603</td>
      <td>True</td>
    </tr>
    <tr>
      <th>6</th>
      <td>100.620615</td>
      <td>True</td>
    </tr>
    <tr>
      <th>12</th>
      <td>101.627951</td>
      <td>True</td>
    </tr>
    <tr>
      <th>5</th>
      <td>104.836660</td>
      <td>True</td>
    </tr>
    <tr>
      <th>8</th>
      <td>105.243441</td>
      <td>True</td>
    </tr>
    <tr>
      <th>1</th>
      <td>107.000517</td>
      <td>True</td>
    </tr>
    <tr>
      <th>13</th>
      <td>109.860833</td>
      <td>True</td>
    </tr>
    <tr>
      <th>3</th>
      <td>113.331765</td>
      <td>True</td>
    </tr>
    <tr>
      <th>7</th>
      <td>123.158849</td>
      <td>True</td>
    </tr>
    <tr>
      <th>9</th>
      <td>124.298799</td>
      <td>True</td>
    </tr>
    <tr>
      <th>10</th>
      <td>103.473383</td>
      <td>False</td>
    </tr>
    <tr>
      <th>14</th>
      <td>112.124853</td>
      <td>False</td>
    </tr>
    <tr>
      <th>11</th>
      <td>113.234472</td>
      <td>False</td>
    </tr>
    <tr>
      <th>0</th>
      <td>129.184647</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>



`ommx_openjij_adapter.sample_qubo_sa` returns `ommx.v1.Samples`, which can be passed to `Instance.evaluate_samples` to calculate the objective function values and constraint violations. The `SampleSet.summary` property is used to display summary information. `feasible` indicates the feasibility to **the original problem** before conversion to QUBO. This is calculated using the information stored in `removed_constraints` of the `qubo` instance.

To view the feasibility for each constraint, use the `summary_with_constraints` property.


```python
sample_set.summary_with_constraints
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>objective</th>
      <th>feasible</th>
      <th>place[0]</th>
      <th>place[1]</th>
      <th>place[2]</th>
      <th>place[3]</th>
      <th>place[4]</th>
      <th>place[5]</th>
      <th>place[6]</th>
      <th>place[7]</th>
      <th>...</th>
      <th>time[6]</th>
      <th>time[7]</th>
      <th>time[8]</th>
      <th>time[9]</th>
      <th>time[10]</th>
      <th>time[11]</th>
      <th>time[12]</th>
      <th>time[13]</th>
      <th>time[14]</th>
      <th>time[15]</th>
    </tr>
    <tr>
      <th>sample_id</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>84.623513</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>4</th>
      <td>94.033786</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>15</th>
      <td>99.704603</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>6</th>
      <td>100.620615</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>12</th>
      <td>101.627951</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>5</th>
      <td>104.836660</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>8</th>
      <td>105.243441</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>1</th>
      <td>107.000517</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>13</th>
      <td>109.860833</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>3</th>
      <td>113.331765</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>7</th>
      <td>123.158849</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>9</th>
      <td>124.298799</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>10</th>
      <td>103.473383</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>14</th>
      <td>112.124853</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>11</th>
      <td>113.234472</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>0</th>
      <td>129.184647</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
  </tbody>
</table>
<p>16 rows × 34 columns</p>
</div>



For more detailed information, you can use the `SampleSet.decision_variables` and `SampleSet.constraints` properties.


```python
sample_set.decision_variables.head(2)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>kind</th>
      <th>lower</th>
      <th>upper</th>
      <th>name</th>
      <th>subscripts</th>
      <th>description</th>
      <th>substituted_value</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>...</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
      <th>10</th>
      <th>11</th>
      <th>12</th>
      <th>13</th>
      <th>14</th>
      <th>15</th>
    </tr>
    <tr>
      <th>id</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>binary</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>x</td>
      <td>[0, 0]</td>
      <td>&lt;NA&gt;</td>
      <td>&lt;NA&gt;</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>16</th>
      <td>binary</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>x</td>
      <td>[1, 0]</td>
      <td>&lt;NA&gt;</td>
      <td>&lt;NA&gt;</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
    </tr>
  </tbody>
</table>
<p>2 rows × 23 columns</p>
</div>




```python
sample_set.constraints.head(2)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>equality</th>
      <th>used_ids</th>
      <th>name</th>
      <th>subscripts</th>
      <th>description</th>
      <th>removed_reason</th>
      <th>value.0</th>
      <th>value.1</th>
      <th>value.2</th>
      <th>value.3</th>
      <th>...</th>
      <th>feasible.3</th>
      <th>feasible.6</th>
      <th>feasible.15</th>
      <th>feasible.12</th>
      <th>feasible.0</th>
      <th>feasible.5</th>
      <th>feasible.8</th>
      <th>feasible.13</th>
      <th>feasible.1</th>
      <th>feasible.4</th>
    </tr>
    <tr>
      <th>id</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>=0</td>
      <td>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,...</td>
      <td>place</td>
      <td>[0]</td>
      <td>&lt;NA&gt;</td>
      <td>uniform_penalty_method</td>
      <td>-1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>1</th>
      <td>=0</td>
      <td>{16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 2...</td>
      <td>place</td>
      <td>[1]</td>
      <td>&lt;NA&gt;</td>
      <td>uniform_penalty_method</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
  </tbody>
</table>
<p>2 rows × 38 columns</p>
</div>



To obtain the samples, use the `SampleSet.extract_decision_variables` method. This interprets the samples using the `name` and `subscripts` registered when creating `ommx.v1.DecisionVariables`. For example, to get the value of the decision variable named `x` with `sample_id=1`, use the following to obtain it in the form of `dict[subscripts, value]`.


```python
sample_id = 1
x = sample_set.extract_decision_variables("x", sample_id)
t = 2
i = 3
x[(t, i)]
```




    0.0



Since we obtained a sample for $x_{t, i}$, we convert this into a TSP path. This depends on the formulation used, so you need to write the processing yourself.


```python
def sample_to_path(sample: dict[tuple[int, ...], float]) -> list[int]:
    path = []
    for t in range(N):
        for i in range(N):
            if sample[(t, i)] == 1:
                path.append(i)
    return path
```

Let's display this. First, we obtain the IDs of samples that are feasible for the original problem.


```python
feasible_ids = sample_set.summary.query("feasible == True").index
feasible_ids
```




    Index([2, 4, 15, 6, 12, 5, 8, 1, 13, 3, 7, 9], dtype='int64', name='sample_id')



Let's display the optimized paths for these samples.


```python
fig, axie = plt.subplots(3, 3, figsize=(12, 12))

for i, ax in enumerate(axie.flatten()):
    if i >= len(feasible_ids):
        break
    s = feasible_ids[i]
    x = sample_set.extract_decision_variables("x", s)
    path = sample_to_path(x)
    xs = [ulysses16_points[i][0] for i in path] + [ulysses16_points[path[0]][0]]
    ys = [ulysses16_points[i][1] for i in path] + [ulysses16_points[path[0]][1]]
    ax.plot(xs, ys, marker='o')
    ax.set_title(f"Sample {s}, objective={sample_set.objectives[s]:.2f}")

plt.tight_layout()
plt.show()
```


    
![png](/tmp/tmp7_xxqc3e/markdown/tsp_sampling_with_openjij_adapter_33_0.png)
    



### Share In Ommx Artifact.Md


In mathematical optimization workflows, it is important to generate and manage a variety of data. Properly handling these data ensures reproducible computational results and allows teams to share information efficiently.

OMMX provides a straightforward and efficient way to manage different data types. Specifically, it defines a data format called an OMMX Artifact, which lets you store, organize, and share various optimization data through the OMMX SDK.

## Preparation: Data to Share

First, let's prepare the data we want to share. We will create an `ommx.v1.Instance` representing the 0-1 knapsack problem and solve it using SCIP. We will also share the results of our optimization analysis. Details are omitted for brevity.


```python
from ommx.v1 import Instance, DecisionVariable, Constraint
from ommx_pyscipopt_adapter.adapter import OMMXPySCIPOptAdapter
import pandas as pd

# Prepare data for the 0-1 knapsack problem
data = {
    # Values of each item
    "v": [10, 13, 18, 31, 7, 15],
    # Weights of each item
    "w": [11, 15, 20, 35, 10, 33],
    # Knapsack capacity
    "W": 47,
    # Total number of items
    "N": 6,
}

# Define decision variables
x = [
    # Define binary variable x_i
    DecisionVariable.binary(
        # Specify the ID of the decision variable
        id=i,
        # Specify the name of the decision variable
        name="x",
        # Specify the subscript of the decision variable
        subscripts=[i],
    )
    # Prepare num_items binary variables
    for i in range(data["N"])
]

# Define the objective function
objective = sum(data["v"][i] * x[i] for i in range(data["N"]))

# Define constraints
constraint = Constraint(
    # Name of the constraint
    name = "Weight Limit",
    # Specify the left-hand side of the constraint
    function=sum(data["w"][i] * x[i] for i in range(data["N"])) - data["W"],
    # Specify equality constraint (==0) or inequality constraint (<=0)
    equality=Constraint.LESS_THAN_OR_EQUAL_TO_ZERO,
)

# Create an instance
instance = Instance.from_components(
    # Register all decision variables included in the instance
    decision_variables=x,
    # Register the objective function
    objective=objective,
    # Register all constraints
    constraints=[constraint],
    # Specify that it is a maximization problem
    sense=Instance.MAXIMIZE,
)

# Solve with SCIP
solution = OMMXPySCIPOptAdapter.solve(instance)

# Analyze the optimal solution
df_vars = solution.decision_variables
df = pd.DataFrame.from_dict(
    {
        "Item Number": df_vars.index,
        "Put in Knapsack?": df_vars["value"].apply(lambda x: "Yes" if x == 1.0 else "No"),
    }
)
```

    /Users/termoshtt/github.com/Jij-Inc/ommx/python/ommx-pyscipopt-adapter/ommx_pyscipopt_adapter/adapter.py:30: UserWarning: linked SCIP 9.02 is not recommended for this version of PySCIPOpt - use version 9.2.1
      self.model = pyscipopt.Model()



```python
from myst_nb import glue

glue("instance", instance, display=False)
glue("solution", solution, display=False)
glue("data", data, display=False)
glue("df", df, display=False)
```









```{list-table}
:header-rows: 1
:widths: 5 30 10

* - Variable Name
  - Description
  - Value
* - `instance`
  - `ommx.v1.Instance` object representing the 0-1 knapsack problem
  - ````{toggle}
    ```{glue:} instance
    ```
    ````
* - `solution`
  - `ommx.v1.Solution` object containing the results of solving the 0-1 knapsack problem with SCIP
  - ````{toggle}
    ```{glue:} solution
    ```
    ````
* - `data`
  - Input data for the 0-1 knapsack problem
  - ```{glue:} data
    ```
* - `df`
  - `pandas.DataFrame` object representing the optimal solution of the 0-1 knapsack problem
  - {glue:}`df`
```

## Creating an OMMX Artifact as a File

OMMX Artifacts can be managed as files or by assigning them container-like names. Here, we'll show how to save the data as a file. Using the OMMX SDK, we'll store the data in a new file called `my_instance.ommx`. First, we need an `ArtifactBuilder`.


```python
import os
from ommx.artifact import ArtifactBuilder

# Specify the name of the OMMX Artifact file
filename = "my_instance.ommx"

# If the file already exists, remove it
if os.path.exists(filename):
    os.remove(filename)

# 1. Create a builder to create the OMMX Artifact file
builder = ArtifactBuilder.new_archive_unnamed(filename)
```

[`ArtifactBuilder`](https://jij-inc.github.io/ommx/python/ommx/autoapi/ommx/artifact/index.html#ommx.artifact.ArtifactBuilder) has several constructors, allowing you to choose whether to manage it by name like a container or as an archive file. If you use a container registry to push and pull like a container, a name is required, but if you use an archive file, a name is not necessary. Here, we use `ArtifactBuilder.new_archive_unnamed` to manage it as an archive file.

| Constructor | Description |
| --- | --- |
| [`ArtifactBuilder.new`](https://jij-inc.github.io/ommx/python/ommx/autoapi/ommx/artifact/index.html#ommx.artifact.ArtifactBuilder.new) | Manage by name like a container |
| [`ArtifactBuilder.new_archive`](https://jij-inc.github.io/ommx/python/ommx/autoapi/ommx/artifact/index.html#ommx.artifact.ArtifactBuilder.new_archive) | Manage as both an archive file and a container |
| [`ArtifactBuilder.new_archive_unnamed`](https://jij-inc.github.io/ommx/python/ommx/autoapi/ommx/artifact/index.html#ommx.artifact.ArtifactBuilder.new_archive_unnamed) | Manage as an archive file |
| [`ArtifactBuilder.for_github`](https://jij-inc.github.io/ommx/python/ommx/autoapi/ommx/artifact/index.html#ommx.artifact.ArtifactBuilder.for_github) | Determine the container name according to the GitHub Container Registry |

Regardless of the initialization method, you can save `ommx.v1.Instance` and other data in the same way. Let's add the data prepared above.


```python
# Add ommx.v1.Instance object
desc_instance = builder.add_instance(instance)

# Add ommx.v1.Solution object
desc_solution = builder.add_solution(solution)

# Add pandas.DataFrame object
desc_df = builder.add_dataframe(df, title="Optimal Solution of Knapsack Problem")

# Add an object that can be converted to JSON
desc_json = builder.add_json(data, title="Data of Knapsack Problem")
```

In OMMX Artifacts, data is stored in layers, each with a dedicated media type. Functions like `add_instance` automatically set these media types and add layers. These functions return a `Description` object with information about each created layer.


```python
desc_json.to_dict()
```




    {'mediaType': 'application/json',
     'digest': 'sha256:6cbfaaa7f97e84d8b46da95b81cf4d5158df3a9bd439f8c60be26adaa16ab3cf',
     'size': 78,
     'annotations': {'org.ommx.user.title': 'Data of Knapsack Problem'}}



The part added as `title="..."` in `add_json` is saved as an annotation of the layer. OMMX Artifact is a data format for humans, so this is basically information for humans to read. The `ArtifactBuilder.add_*` functions all accept optional keyword arguments and automatically convert them to the `org.ommx.user.` namespace.

Finally, call `build` to save it to a file.


```python
# 3. Create the OMMX Artifact file
artifact = builder.build()
```

This `artifact` is the same as the one that will be explained in the next section, which is the one you just saved. Let's check if the file has been created:


```python
! ls -l $filename
```

    -rw-r--r--  1 termoshtt  staff  11264 Feb 12 21:13 my_instance.ommx


Now you can share this `my_instance.ommx` with others using the usual file sharing methods.

## Read OMMX Artifact file

Next, let's read the OMMX Artifact we saved. When loading an OMMX Artifact in archive format, use [`Artifact.load_archive`](https://jij-inc.github.io/ommx/python/ommx/autoapi/ommx/artifact/index.html#ommx.artifact.Artifact.load_archive).


```python
from ommx.artifact import Artifact

# Load the OMMX Artifact file locally
artifact = Artifact.load_archive(filename)
```

OMMX Artifacts store data in layers, with a manifest (catalog) that details their contents. You can check the `Descriptor` of each layer, including its Media Type and annotations, without reading the entire archive.


```python
import pandas as pd

# Convert to pandas.DataFrame for better readability
pd.DataFrame({
    "Media Type": desc.media_type,
    "Size (Bytes)": desc.size
  } | desc.annotations
  for desc in artifact.layers
)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Media Type</th>
      <th>Size (Bytes)</th>
      <th>org.ommx.user.title</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>application/org.ommx.v1.instance</td>
      <td>325</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>application/org.ommx.v1.solution</td>
      <td>266</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>application/vnd.apache.parquet</td>
      <td>2595</td>
      <td>Optimal Solution of Knapsack Problem</td>
    </tr>
    <tr>
      <th>3</th>
      <td>application/json</td>
      <td>78</td>
      <td>Data of Knapsack Problem</td>
    </tr>
  </tbody>
</table>
</div>



For instance, to retrieve the JSON in layer 3, use [`Artifact.get_json`](https://jij-inc.github.io/ommx/python/ommx/autoapi/ommx/artifact/index.html#ommx.artifact.Artifact.get_json). This function confirms that the Media Type is `application/json` and reinstates the bytes into a Python object.


```python
artifact.get_json(artifact.layers[3])
```




    {'v': [10, 13, 18, 31, 7, 15], 'w': [11, 15, 20, 35, 10, 33], 'W': 47, 'N': 6}




```python
# Remove the created OMMX Artifact file to clean up
! rm $filename
```


### Download Miplib Instance.Md


The OMMX repository provides mixed-integer programming benchmark instances from MIPLIB 2017 in OMMX Artifact format.

```{note}
More details: The MIPLIB 2017 instances in OMMX Artifact format are hosted in the GitHub Container Registry for the OMMX repository ([link](https://github.com/Jij-Inc/ommx/pkgs/container/ommx%2Fmiplib2017)).

Please see [this page](https://docs.github.com/ja/packages/working-with-a-github-packages-registry/working-with-the-container-registry) for information on GitHub Container Registry.
```

You can easily download these instances with the OMMX SDK, then directly use them as inputs to OMMX Adapters.
For example, to solve the air05 instance from MIPLIB 2017 ([reference](https://miplib.zib.de/instance_details_air05.html)) with PySCIPOpt, you can:

1. Download the air05 instance with `dataset.miplib2017` from the OMMX Python SDK.
2. Solve with PySCIPOpt via the OMMX PySCIPOpt Adapter.

Here is a sample Python code:


```python
# OMMX Python SDK
from ommx import dataset
# OMMX PySCIPOpt Adapter
from ommx_pyscipopt_adapter import OMMXPySCIPOptAdapter

# Step 1: Download the air05 instance from MIPLIB 2017
instance = dataset.miplib2017("air05")

# Step 2: Solve with PySCIPOpt via the OMMX PySCIPOpt Adapter
solution = OMMXPySCIPOptAdapter.solve(instance)
```

This functionality makes it easy to run benchmark tests on multiple OMMX-compatible solvers using the same MIPLIB instances.

## Note about Annotations with the Instance

The downloaded instance includes various annotations accessible via the `annotations` property:


```python
import pandas as pd
# Display annotations in tabular form using pandas
pd.DataFrame.from_dict(instance.annotations, orient="index", columns=["Value"]).sort_index()
```

These instances have both dataset-level annotations and dataset-specific annotations.

There are seven dataset-wide annotations with dedicated properties:

| Annotation                                    | Property          | Description                                               |
|----------------------------------------------|-------------------|-----------------------------------------------------------|
| `org.ommx.v1.instance.authors`               | `authors`         | The authors of the instance                              |
| `org.ommx.v1.instance.constraints`           | `num_constraints` | The number of constraint conditions in the instance      |
| `org.ommx.v1.instance.created`               | `created`         | The date of the instance was saved as an OMMX Artifact   |
| `org.ommx.v1.instance.dataset`               | `dataset`         | The name of the dataset to which this instance belongs   |
| `org.ommx.v1.instance.license`               | `license`         | The license of this dataset                              |
| `org.ommx.v1.instance.title`                 | `title`           | The name of the instance                                 |
| `org.ommx.v1.instance.variables`             | `num_variables`   | The total number of decision variables in the instance   |

MIPLIB-specific annotations are prefixed with `org.ommx.miplib.*`.

For example, the optimal objective of the air05 instance is `26374`, which you can check with the key `org.ommx.miplib.objective`:



```python
# Note that the values of annotations are all strings (str)!
assert instance.annotations["org.ommx.miplib.objective"] == "26374"
```

Thus, we can verify that the optimization result from the OMMX PySCIPOpt Adapter matches the expected optimal value.


```python
import numpy as np

best = float(instance.annotations["org.ommx.miplib.objective"])
assert np.isclose(solution.objective, best)
```


## API Reference

### __init__

```python
"""
This type stub file was generated by pyright.
"""

"""
This type stub file was generated by pyright.
"""

```

### _ommx_rust

```python
"""
This type stub file was generated by pyright.
"""

import os
import pathlib
import typing

"""
This type stub file was generated by pyright.
"""
class ArtifactArchive:
    image_name: typing.Optional[str]
    annotations: dict[str, str]
    layers: list[Descriptor]
    @staticmethod
    def from_oci_archive(path: str | os.PathLike | pathlib.Path) -> ArtifactArchive:
        ...
    
    def get_blob(self, digest: str) -> bytes:
        ...
    
    def push(self) -> None:
        ...
    


class ArtifactArchiveBuilder:
    @staticmethod
    def new_unnamed(path: str | os.PathLike | pathlib.Path) -> ArtifactArchiveBuilder:
        ...
    
    @staticmethod
    def new(path: str | os.PathLike | pathlib.Path, image_name: str) -> ArtifactArchiveBuilder:
        ...
    
    @staticmethod
    def temp() -> ArtifactArchiveBuilder:
        ...
    
    def add_layer(self, media_type: str, blob: bytes, annotations: typing.Mapping[str, str]) -> Descriptor:
        ...
    
    def add_annotation(self, key: str, value: str) -> None:
        ...
    
    def build(self) -> ArtifactArchive:
        ...
    


class ArtifactDir:
    image_name: typing.Optional[str]
    annotations: dict[str, str]
    layers: list[Descriptor]
    @staticmethod
    def from_image_name(image_name: str) -> ArtifactDir:
        ...
    
    @staticmethod
    def from_oci_dir(path: str | os.PathLike | pathlib.Path) -> ArtifactDir:
        ...
    
    def get_blob(self, digest: str) -> bytes:
        ...
    
    def push(self) -> None:
        ...
    


class ArtifactDirBuilder:
    @staticmethod
    def new(image_name: str) -> ArtifactDirBuilder:
        ...
    
    @staticmethod
    def for_github(org: str, repo: str, name: str, tag: str) -> ArtifactDirBuilder:
        ...
    
    def add_layer(self, media_type: str, blob: bytes, annotations: typing.Mapping[str, str]) -> Descriptor:
        ...
    
    def add_annotation(self, key: str, value: str) -> None:
        ...
    
    def build(self) -> ArtifactDir:
        ...
    


class Descriptor:
    r"""
    Descriptor of blob in artifact
    """
    digest: str
    size: int
    media_type: str
    annotations: dict[str, str]
    user_annotations: dict[str, str]
    def to_dict(self) -> dict:
        ...
    
    @staticmethod
    def from_dict(dict: dict) -> Descriptor:
        ...
    
    def to_json(self) -> str:
        ...
    
    @staticmethod
    def from_json(json: str) -> Descriptor:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __eq__(self, rhs: typing.Any) -> bool:
        ...
    


class Function:
    @staticmethod
    def from_scalar(scalar: float) -> Function:
        ...
    
    @staticmethod
    def from_linear(linear: Linear) -> Function:
        ...
    
    @staticmethod
    def from_quadratic(quadratic: Quadratic) -> Function:
        ...
    
    @staticmethod
    def from_polynomial(polynomial: Polynomial) -> Function:
        ...
    
    @staticmethod
    def decode(bytes: bytes) -> Function:
        ...
    
    def encode(self) -> bytes:
        ...
    
    def almost_equal(self, other: Function, atol: float) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __add__(self, rhs: Function) -> Function:
        ...
    
    def __sub__(self, rhs: Function) -> Function:
        ...
    
    def __mul__(self, rhs: Function) -> Function:
        ...
    
    def add_scalar(self, scalar: float) -> Function:
        ...
    
    def add_linear(self, linear: Linear) -> Function:
        ...
    
    def add_quadratic(self, quadratic: Quadratic) -> Function:
        ...
    
    def add_polynomial(self, polynomial: Polynomial) -> Function:
        ...
    
    def mul_scalar(self, scalar: float) -> Function:
        ...
    
    def mul_linear(self, linear: Linear) -> Function:
        ...
    
    def mul_quadratic(self, quadratic: Quadratic) -> Function:
        ...
    
    def mul_polynomial(self, polynomial: Polynomial) -> Function:
        ...
    


class Instance:
    @staticmethod
    def from_bytes(bytes: bytes) -> Instance:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    
    def validate(self) -> None:
        ...
    
    def as_pubo_format(self) -> dict:
        ...
    
    def as_qubo_format(self) -> tuple[dict, float]:
        ...
    
    def as_parametric_instance(self) -> ParametricInstance:
        ...
    
    def penalty_method(self) -> ParametricInstance:
        ...
    
    def uniform_penalty_method(self) -> ParametricInstance:
        ...
    
    def evaluate_samples(self, samples: Samples) -> SampleSet:
        ...
    
    def relax_constraint(self, constraint_id: int, removed_reason: str, removed_reason_parameters: typing.Mapping[str, str]) -> None:
        ...
    
    def restore_constraint(self, constraint_id: int) -> None:
        ...
    


class Linear:
    @staticmethod
    def single_term(id: int, coefficient: float) -> Linear:
        ...
    
    @staticmethod
    def decode(bytes: bytes) -> Linear:
        ...
    
    def encode(self) -> bytes:
        ...
    
    def almost_equal(self, other: Linear, atol: float) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __add__(self, rhs: Linear) -> Linear:
        ...
    
    def __sub__(self, rhs: Linear) -> Linear:
        ...
    
    def __mul__(self, rhs: Linear) -> Quadratic:
        ...
    
    def add_scalar(self, scalar: float) -> Linear:
        ...
    
    def mul_scalar(self, scalar: float) -> Linear:
        ...
    


class Parameters:
    @staticmethod
    def from_bytes(bytes: bytes) -> Parameters:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    


class ParametricInstance:
    @staticmethod
    def from_bytes(bytes: bytes) -> ParametricInstance:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    
    def validate(self) -> None:
        ...
    
    def with_parameters(self, parameters: Parameters) -> Instance:
        ...
    


class Polynomial:
    @staticmethod
    def decode(bytes: bytes) -> Polynomial:
        ...
    
    def encode(self) -> bytes:
        ...
    
    def almost_equal(self, other: Polynomial, atol: float) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __add__(self, rhs: Polynomial) -> Polynomial:
        ...
    
    def __sub__(self, rhs: Polynomial) -> Polynomial:
        ...
    
    def __mul__(self, rhs: Polynomial) -> Polynomial:
        ...
    
    def add_scalar(self, scalar: float) -> Polynomial:
        ...
    
    def add_linear(self, linear: Linear) -> Polynomial:
        ...
    
    def add_quadratic(self, quadratic: Quadratic) -> Polynomial:
        ...
    
    def mul_scalar(self, scalar: float) -> Polynomial:
        ...
    
    def mul_linear(self, linear: Linear) -> Polynomial:
        ...
    
    def mul_quadratic(self, quadratic: Quadratic) -> Polynomial:
        ...
    


class Quadratic:
    @staticmethod
    def decode(bytes: bytes) -> Quadratic:
        ...
    
    def encode(self) -> bytes:
        ...
    
    def almost_equal(self, other: Quadratic, atol: float) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __add__(self, rhs: Quadratic) -> Quadratic:
        ...
    
    def __sub__(self, rhs: Quadratic) -> Quadratic:
        ...
    
    def __mul__(self, rhs: Quadratic) -> Polynomial:
        ...
    
    def add_scalar(self, scalar: float) -> Quadratic:
        ...
    
    def add_linear(self, linear: Linear) -> Quadratic:
        ...
    
    def mul_scalar(self, scalar: float) -> Quadratic:
        ...
    
    def mul_linear(self, linear: Linear) -> Polynomial:
        ...
    


class SampleSet:
    @staticmethod
    def from_bytes(bytes: bytes) -> SampleSet:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    
    def get(self, sample_id: int) -> Solution:
        ...
    
    def num_samples(self) -> int:
        ...
    
    def sample_ids(self) -> set[int]:
        ...
    
    def feasible_ids(self) -> set[int]:
        ...
    
    def feasible_unrelaxed_ids(self) -> set[int]:
        ...
    
    def best_feasible(self) -> Solution:
        ...
    
    def best_feasible_unrelaxed(self) -> Solution:
        ...
    


class Samples:
    @staticmethod
    def from_bytes(bytes: bytes) -> Samples:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    


class Solution:
    @staticmethod
    def from_bytes(bytes: bytes) -> Solution:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    


def evaluate_constraint(function: bytes, state: bytes) -> tuple[bytes, set[int]]:
    ...

def evaluate_function(function: bytes, state: bytes) -> tuple[float, set[int]]:
    ...

def evaluate_instance(function: bytes, state: bytes) -> tuple[bytes, set[int]]:
    ...

def evaluate_linear(function: bytes, state: bytes) -> tuple[float, set[int]]:
    ...

def evaluate_polynomial(function: bytes, state: bytes) -> tuple[float, set[int]]:
    ...

def evaluate_quadratic(function: bytes, state: bytes) -> tuple[float, set[int]]:
    ...

def load_mps_bytes(path: str) -> bytes:
    ...

def load_qplib_bytes(path: str) -> bytes:
    ...

def miplib2017_instance_annotations() -> dict[str, dict[str, str]]:
    ...

def partial_evaluate_constraint(obj: bytes, state: bytes) -> tuple[bytes, set[int]]:
    ...

def partial_evaluate_function(function: bytes, state: bytes) -> tuple[bytes, set[int]]:
    ...

def partial_evaluate_instance(obj: bytes, state: bytes) -> tuple[bytes, set[int]]:
    ...

def partial_evaluate_linear(function: bytes, state: bytes) -> tuple[bytes, set[int]]:
    ...

def partial_evaluate_polynomial(function: bytes, state: bytes) -> tuple[bytes, set[int]]:
    ...

def partial_evaluate_quadratic(function: bytes, state: bytes) -> tuple[bytes, set[int]]:
    ...

def used_decision_variable_ids(function: bytes) -> set[int]:
    ...

def write_mps_file(instance: bytes, path: str) -> None:
    ...


```

### adapter

```python
"""
This type stub file was generated by pyright.
"""

from abc import ABC, abstractmethod
from typing import Any
from ommx.v1 import Instance, Solution

"""
This type stub file was generated by pyright.
"""
SolverInput = Any
SolverOutput = Any
class SolverAdapter(ABC):
    """
    An abstract interface for Adapters, defining how solvers should be used with OMMX.

    See the `implementation guide` for more details.
    .. _implementation guide: https://jij-inc.github.io/ommx/ommx_ecosystem/solver_adapter_guide.html
    """
    @abstractmethod
    def __init__(self, ommx_instance: Instance) -> None:
        ...
    
    @staticmethod
    @abstractmethod
    def solve(ommx_instance: Instance) -> Solution:
        ...
    
    @property
    @abstractmethod
    def solver_input(self) -> SolverInput:
        ...
    
    @abstractmethod
    def decode(self, data: SolverOutput) -> Solution:
        ...
    


class InfeasibleDetected(Exception):
    ...


class UnboundedDetected(Exception):
    ...



```

### artifact

```python
"""
This type stub file was generated by pyright.
"""

import pandas
import numpy
from dataclasses import dataclass
from pathlib import Path
from abc import ABC, abstractmethod
from ._ommx_rust import ArtifactArchive as _ArtifactArchive, ArtifactArchiveBuilder as _ArtifactArchiveBuilder, ArtifactDir as _ArtifactDir, ArtifactDirBuilder as _ArtifactDirBuilder, Descriptor
from .v1 import Instance, ParametricInstance, SampleSet, Solution

"""
This type stub file was generated by pyright.
"""
class ArtifactBase(ABC):
    @property
    @abstractmethod
    def image_name(self) -> str | None:
        ...
    
    @property
    @abstractmethod
    def annotations(self) -> dict[str, str]:
        ...
    
    @property
    @abstractmethod
    def layers(self) -> list[Descriptor]:
        ...
    
    @abstractmethod
    def get_blob(self, digest: str) -> bytes:
        ...
    
    @abstractmethod
    def push(self):
        ...
    


@dataclass
class ArtifactArchive(ArtifactBase):
    _base: _ArtifactArchive
    @staticmethod
    def from_oci_archive(path: str) -> ArtifactArchive:
        ...
    
    @property
    def image_name(self) -> str | None:
        ...
    
    @property
    def annotations(self) -> dict[str, str]:
        ...
    
    @property
    def layers(self) -> list[Descriptor]:
        ...
    
    def get_blob(self, digest: str) -> bytes:
        ...
    
    def push(self):
        ...
    


@dataclass
class ArtifactDir(ArtifactBase):
    _base: _ArtifactDir
    @staticmethod
    def from_oci_dir(path: str) -> ArtifactDir:
        ...
    
    @staticmethod
    def from_image_name(image_name: str) -> ArtifactDir:
        ...
    
    @property
    def image_name(self) -> str | None:
        ...
    
    @property
    def annotations(self) -> dict[str, str]:
        ...
    
    @property
    def layers(self) -> list[Descriptor]:
        ...
    
    def get_blob(self, digest: str) -> bytes:
        ...
    
    def push(self):
        ...
    


@dataclass
class Artifact:
    """
    Reader for OMMX Artifacts.
    """
    _base: ArtifactBase
    @staticmethod
    def load_archive(path: str | Path) -> Artifact:
        """
        Load an artifact stored as a single file

        >>> artifact = Artifact.load_archive("data/random_lp_instance.ommx")
        >>> print(artifact.image_name)
        ghcr.io/jij-inc/ommx/random_lp_instance:...
        >>> for layer in artifact.layers:
        ...     print(layer.digest)
        sha256:...

        """
        ...
    
    @staticmethod
    def load(image_name: str) -> Artifact:
        """
        Load an artifact stored as container image in local or remote registry

        If the image is not found in local registry, it will try to pull from remote registry.

        >>> artifact = Artifact.load("ghcr.io/jij-inc/ommx/random_lp_instance:4303c7f")
        >>> print(artifact.image_name)
        ghcr.io/jij-inc/ommx/random_lp_instance:4303c7f
        >>> for layer in artifact.layers:
        ...    print(layer.digest)
        sha256:93fdc9fcb8e21b34e3517809a348938d9455e9b9e579548bbf018a514c082df2

        """
        ...
    
    def push(self):
        """
        Push the artifact to remote registry
        """
        ...
    
    @property
    def image_name(self) -> str | None:
        ...
    
    @property
    def annotations(self) -> dict[str, str]:
        """
        Annotations in the artifact manifest

        >>> artifact = Artifact.load("ghcr.io/jij-inc/ommx/random_lp_instance:4303c7f")
        >>> print(artifact.annotations['org.opencontainers.image.source'])
        https://github.com/Jij-Inc/ommx
        >>> print(artifact.annotations['org.opencontainers.image.description'])
        Test artifact created by examples/artifact_archive.rs

        """
        ...
    
    @property
    def layers(self) -> list[Descriptor]:
        ...
    
    def get_layer_descriptor(self, digest: str) -> Descriptor:
        """
        Look up a layer descriptor by digest

        >>> artifact = Artifact.load("ghcr.io/jij-inc/ommx/random_lp_instance:4303c7f")
        >>> layer = artifact.get_layer_descriptor("sha256:93fdc9fcb8e21b34e3517809a348938d9455e9b9e579548bbf018a514c082df2")
        >>> print(layer.media_type)
        application/org.ommx.v1.instance

        """
        ...
    
    def get_blob(self, digest: str | Descriptor) -> bytes:
        ...
    
    def get_layer(self, descriptor: Descriptor) -> Instance | Solution | numpy.ndarray:
        """
        Get the layer object corresponding to the descriptor

        This is dynamically dispatched based on the :py:attr:`Descriptor.media_type`.
        """
        ...
    
    @property
    def instance(self) -> Instance:
        """
        Take the first instance layer in the artifact

        - If the artifact does not contain any instance layer, it raises an :py:exc:`ValueError`.
        - For multiple instance layers, use :py:meth:`Artifact.get_instance` instead.
        """
        ...
    
    def get_instance(self, descriptor: Descriptor) -> Instance:
        """
        Get an instance from the artifact

        >>> artifact = Artifact.load("ghcr.io/jij-inc/ommx/random_lp_instance:4303c7f")

        We know that this artifact has only one layer of type `application/org.ommx.v1.instance`

        >>> desc = artifact.layers[0]
        >>> instance = artifact.get_instance(desc)

        Annotations stored in the artifact is available as attributes

        >>> print(instance.title)
        random_lp
        >>> print(instance.created)
        2024-05-28 08:40:28.728169+00:00

        """
        ...
    
    @property
    def solution(self) -> Solution:
        """
        Take the first solution layer in the artifact

        - If the artifact does not have a solution layer, it raises an :py:exc:`ValueError`.
        - For multiple solution layers, use :py:meth:`Artifact.get_solution` instead.
        """
        ...
    
    def get_solution(self, descriptor: Descriptor) -> Solution:
        ...
    
    @property
    def parametric_instance(self) -> ParametricInstance:
        """
        Take the first parametric instance layer in the artifact

        - If the artifact does not have a parametric instance layer, it raises an :py:exc:`ValueError`.
        - For multiple parametric instance layers, use :py:meth:`Artifact.get_parametric_instance` instead.
        """
        ...
    
    def get_parametric_instance(self, descriptor: Descriptor) -> ParametricInstance:
        """
        Get an parametric instance from the artifact
        """
        ...
    
    @property
    def sample_set(self) -> SampleSet:
        """
        Take the first sample set layer in the artifact

        - If the artifact does not have a sample set layer, it raises an :py:exc:`ValueError`.
        - For multiple sample set layers, use :py:meth:`Artifact.get_sample_set` instead.
        """
        ...
    
    def get_sample_set(self, descriptor: Descriptor) -> SampleSet:
        """
        Get a sample set from the artifact
        """
        ...
    
    def get_ndarray(self, descriptor: Descriptor) -> numpy.ndarray:
        """
        Get a numpy array from an artifact layer stored by :py:meth:`ArtifactBuilder.add_ndarray`
        """
        ...
    
    def get_dataframe(self, descriptor: Descriptor) -> pandas.DataFrame:
        """
        Get a pandas DataFrame from an artifact layer stored by :py:meth:`ArtifactBuilder.add_dataframe`
        """
        ...
    
    def get_json(self, descriptor: Descriptor):
        """
        Get a JSON object from an artifact layer stored by :py:meth:`ArtifactBuilder.add_json`
        """
        ...
    


class ArtifactBuilderBase(ABC):
    @abstractmethod
    def add_layer(self, media_type: str, blob: bytes, annotations: dict[str, str]) -> Descriptor:
        ...
    
    @abstractmethod
    def add_annotation(self, key: str, value: str):
        ...
    
    @abstractmethod
    def build(self) -> ArtifactBase:
        ...
    


@dataclass
class ArtifactArchiveBuilder(ArtifactBuilderBase):
    _base: _ArtifactArchiveBuilder
    @staticmethod
    def new(path: str, image_name: str) -> ArtifactArchiveBuilder:
        ...
    
    @staticmethod
    def new_unnamed(path: str) -> ArtifactArchiveBuilder:
        ...
    
    @staticmethod
    def temp() -> ArtifactArchiveBuilder:
        ...
    
    def add_layer(self, media_type: str, blob: bytes, annotations: dict[str, str] = ...) -> Descriptor:
        ...
    
    def add_annotation(self, key: str, value: str):
        ...
    
    def build(self) -> ArtifactArchive:
        ...
    


@dataclass
class ArtifactDirBuilder(ArtifactBuilderBase):
    _base: _ArtifactDirBuilder
    @staticmethod
    def new(image_name: str) -> ArtifactDirBuilder:
        ...
    
    @staticmethod
    def for_github(org: str, repo: str, name: str, tag: str) -> ArtifactDirBuilder:
        ...
    
    def add_layer(self, media_type: str, blob: bytes, annotations: dict[str, str] = ...) -> Descriptor:
        ...
    
    def add_annotation(self, key: str, value: str):
        ...
    
    def build(self) -> ArtifactDir:
        ...
    


@dataclass(frozen=True)
class ArtifactBuilder:
    """
    Builder for OMMX Artifacts.
    """
    _base: ArtifactBuilderBase
    @staticmethod
    def new_archive_unnamed(path: str | Path) -> ArtifactBuilder:
        """
        Create a new artifact archive with an unnamed image name. This cannot be loaded into local registry nor pushed to remote registry.

        Example
        ========

        Ready instance to be added to the artifact

        >>> from ommx.testing import SingleFeasibleLPGenerator, DataType
        >>> generator = SingleFeasibleLPGenerator(3, DataType.INT)
        >>> instance = generator.get_v1_instance()

        File name for the artifact

        >>> import uuid  # To generate a unique name for testing
        >>> filename = f"data/single_feasible_lp.ommx.{uuid.uuid4()}"

        Build the artifact

        >>> builder = ArtifactBuilder.new_archive_unnamed(filename)
        >>> _desc = builder.add_instance(instance)
        >>> artifact = builder.build()

        In this case, the :py:attr:`Artifact.image_name` is `None`.

        >>> print(artifact.image_name)
        None

        """
        ...
    
    @staticmethod
    def new_archive(path: str | Path, image_name: str) -> ArtifactBuilder:
        """
        Create a new artifact archive with a named image name

        Example
        ========

        Ready instance to be added to the artifact

        >>> from ommx.testing import SingleFeasibleLPGenerator, DataType
        >>> generator = SingleFeasibleLPGenerator(3, DataType.INT)
        >>> instance = generator.get_v1_instance()

        File name and image name for the artifact.

        >>> import uuid  # To generate a unique name for testing
        >>> tag = uuid.uuid4()
        >>> filename = f"data/single_feasible_lp.ommx.{tag}"
        >>> image_name = f"ghcr.io/jij-inc/ommx/single_feasible_lp:{tag}"

        Build the artifact

        >>> builder = ArtifactBuilder.new_archive(filename, image_name)
        >>> _desc = builder.add_instance(instance)
        >>> artifact = builder.build()

        >>> print(artifact.image_name)
        ghcr.io/jij-inc/ommx/single_feasible_lp:...

        """
        ...
    
    @staticmethod
    def new(image_name: str) -> ArtifactBuilder:
        """
        Create a new artifact in local registry with a named image name

        Example
        ========

        Ready instance to be added to the artifact

        >>> from ommx.testing import SingleFeasibleLPGenerator, DataType
        >>> generator = SingleFeasibleLPGenerator(3, DataType.INT)
        >>> instance = generator.get_v1_instance()

        Image name for the artifact

        >>> import uuid  # To generate a unique name for testing
        >>> image_name = f"ghcr.io/jij-inc/ommx/single_feasible_lp:{uuid.uuid4()}"

        Build the artifact

        >>> builder = ArtifactBuilder.new(image_name)
        >>> _desc = builder.add_instance(instance)
        >>> artifact = builder.build()

        >>> print(artifact.image_name)
        ghcr.io/jij-inc/ommx/single_feasible_lp:...

        """
        ...
    
    @staticmethod
    def temp() -> ArtifactBuilder:
        """
        Create a new artifact as a temporary file. Note that this is insecure and should only be used for testing.

        >>> builder = ArtifactBuilder.temp()
        >>> artifact = builder.build()

        Image name is set by random UUID, and can be pushed to https://ttl.sh/ registry. This will be removed after 1 hour.

        >>> print(artifact.image_name)
        ttl.sh/...-...-...-...-...:1h
        >>> artifact.push()

        """
        ...
    
    @staticmethod
    def for_github(org: str, repo: str, name: str, tag: str) -> ArtifactBuilder:
        """
        An alias for :py:meth:`new` to create a new artifact in local registry with GitHub Container Registry image name

        This also set the `org.opencontainers.image.source` annotation to the GitHub repository URL.

        Example
        ========

        Ready instance to be added to the artifact

        >>> from ommx.testing import SingleFeasibleLPGenerator, DataType
        >>> generator = SingleFeasibleLPGenerator(3, DataType.INT)
        >>> instance = generator.get_v1_instance()

        Build the artifact

        >>> import uuid  # To generate a unique name for testing
        >>> builder = ArtifactBuilder.for_github(
        ...    "Jij-Inc", "ommx", "single_feasible_lp", str(uuid.uuid4())
        ... )
        >>> _desc = builder.add_instance(instance)
        >>> artifact = builder.build()

        >>> print(artifact.image_name)
        ghcr.io/jij-inc/ommx/single_feasible_lp:...

        """
        ...
    
    def add_instance(self, instance: Instance) -> Descriptor:
        """
        Add an instance to the artifact with annotations

        Example
        ========

        >>> from ommx.v1 import Instance
        >>> instance = Instance.empty()

        Set annotations into the instance itself
        >>> instance.title = "test instance"
        >>> instance.add_user_annotation("author", "Alice")

        Add the instance to the artifact
        >>> builder = ArtifactBuilder.temp()
        >>> desc = builder.add_instance(instance)
        >>> print(desc.annotations['org.ommx.v1.instance.title'])
        test instance
        >>> print(desc.annotations['org.ommx.user.author'])
        Alice
        >>> artifact = builder.build()

        Load the instance from the artifact by :py:meth:`Artifact.get_instance`
        >>> instance2 = artifact.get_instance(desc)
        >>> print(instance2.title)
        test instance
        >>> print(instance2.get_user_annotations())
        {'author': 'Alice'}

        """
        ...
    
    def add_parametric_instance(self, instance: ParametricInstance) -> Descriptor:
        """
        Add a parametric instance to the artifact with annotations
        """
        ...
    
    def add_solution(self, solution: Solution) -> Descriptor:
        """
        Add a solution to the artifact with annotations

        Example
        ========

        >>> from ommx.v1 import Instance, Solution
        >>> instance = Instance.empty()
        >>> solution = instance.evaluate({})

        Add the instance to the artifact first
        >>> builder = ArtifactBuilder.temp()
        >>> instance_desc = builder.add_instance(instance)

        Set annotations into the solution itself
        >>> solution.instance = instance_desc.digest
        >>> solution.solver = "manual"
        >>> solution.add_user_annotation("title", "test solution")
        >>> _desc = builder.add_solution(solution)
        >>> artifact = builder.build()

        Load the solution from the artifact by :py:meth:`Artifact.get_solution`
        >>> solution2 = artifact.get_solution(_desc)
        >>> print(solution2.instance)
        sha256:...
        >>> print(solution2.solver)
        manual
        >>> print(solution2.get_user_annotations())
        {'title': 'test solution'}

        """
        ...
    
    def add_sample_set(self, sample_set: SampleSet) -> Descriptor:
        """
        Add a sample set to the artifact with annotations
        """
        ...
    
    def add_ndarray(self, array: numpy.ndarray, /, *, annotation_namespace: str = ..., **annotations: str) -> Descriptor:
        """
        Add a numpy ndarray to the artifact with npy format

        Example
        ========

        >>> import numpy as np
        >>> array = np.array([1, 2, 3])

        Store the array in the artifact with `application/vnd.numpy` media type. We can also add annotations to the layer.

        >>> builder = ArtifactBuilder.temp()
        >>> _desc = builder.add_ndarray(array, title="test_array")
        >>> artifact = builder.build()

        The `title` annotation is stored as `org.ommx.user.title` in the artifact, which can be accessed by :py:attr:`Descriptor.annotations` or :py:attr:`Descriptor.user_annotations`.

        >>> layer = artifact.layers[0]
        >>> print(layer.media_type)
        application/vnd.numpy
        >>> print(layer.annotations)
        {'org.ommx.user.title': 'test_array'}
        >>> print(layer.user_annotations)
        {'title': 'test_array'}

        Load the array from the artifact by :py:meth:`Artifact.get_ndarray`

        >>> ndarray = artifact.get_ndarray(layer)
        >>> print(ndarray)
        [1 2 3]

        """
        ...
    
    def add_dataframe(self, df: pandas.DataFrame, /, *, annotation_namespace: str = ..., **annotations: str) -> Descriptor:
        """
        Add a pandas DataFrame to the artifact with parquet format

        Example
        ========
        >>> import pandas as pd
        >>> df = pd.DataFrame({"a": [1, 2], "b": [3, 4]})

        Store the DataFrame in the artifact with `application/vnd.apache.parquet` media type.

        >>> builder = ArtifactBuilder.temp()
        >>> _desc = builder.add_dataframe(df, title="test_dataframe")
        >>> artifact = builder.build()

        The `title` annotation is stored as `org.ommx.user.title` in the artifact, which can be accessed by :py:attr:`Descriptor.annotations` or :py:attr:`Descriptor.user_annotations`.

        >>> layer = artifact.layers[0]
        >>> print(layer.media_type)
        application/vnd.apache.parquet
        >>> print(layer.annotations)
        {'org.ommx.user.title': 'test_dataframe'}
        >>> print(layer.user_annotations)
        {'title': 'test_dataframe'}

        >>> df2 = artifact.get_dataframe(layer)
        >>> assert df.equals(df2)

        You can use another namespace for annotations via `annotation_namespace` argument.

        >>> builder = ArtifactBuilder.temp()
        >>> desc = builder.add_dataframe(df, annotation_namespace="org.ommx.user2.", title="test_dataframe")
        >>> print(desc.annotations)
        {'org.ommx.user2.title': 'test_dataframe'}

        """
        ...
    
    def add_json(self, obj, /, *, annotation_namespace: str = ..., **annotations: str) -> Descriptor:
        """
        Add a JSON object to the artifact

        Example
        ========

        >>> obj = {"a": 1, "b": 2}

        Store the object in the artifact with `application/json` media type.

        >>> builder = ArtifactBuilder.temp()
        >>> _desc = builder.add_json(obj, title="test_json")
        >>> artifact = builder.build()

        The `title` annotation is stored as `org.ommx.user.title` in the artifact, which can be accessed by :py:attr:`Descriptor.annotations` or :py:attr:`Descriptor.user_annotations`.

        >>> layer = artifact.layers[0]
        >>> print(layer.media_type)
        application/json
        >>> print(layer.annotations)
        {'org.ommx.user.title': 'test_json'}
        >>> print(layer.user_annotations)
        {'title': 'test_json'}

        """
        ...
    
    def add_layer(self, media_type: str, blob: bytes, annotations: dict[str, str] = ...) -> Descriptor:
        """
        Low-level API to add any type of layer to the artifact with annotations. Use :meth:`add_instance` or other high-level methods if possible.
        """
        ...
    
    def add_annotation(self, key: str, value: str):
        """
        Add annotation to the artifact itself.
        """
        ...
    
    def build(self) -> Artifact:
        """
        Build the artifact.
        """
        ...
    



```

### dataset

```python
"""
This type stub file was generated by pyright.
"""

from . import v1

"""
This type stub file was generated by pyright.
"""
def miplib2017(name: str) -> v1.Instance:
    """
    Load a MIPLIB 2017 instance as OMMX Artifact.

    >>> from ommx.dataset import miplib2017
    >>> instance = miplib2017("air05")

    Common annotations

    >>> instance.title
    'air05'
    >>> instance.authors
    ['G. Astfalk']
    >>> instance.license
    'CC-BY-SA-4.0'
    >>> instance.num_variables
    7195
    >>> instance.num_constraints
    426

    MIPLIB-specific annotations are stored with `org.ommx.miplib.*` keys.

    >>> instance.annotations["org.ommx.miplib.binaries"]
    '7195'
    >>> instance.annotations["org.ommx.miplib.integers"]
    '0'
    >>> instance.annotations["org.ommx.miplib.continuous"]
    '0'
    >>> instance.annotations["org.ommx.miplib.non_zero"]
    '52121'

    >>> instance.annotations["org.ommx.miplib.status"]
    'easy'
    >>> instance.annotations["org.ommx.miplib.objective"]
    '26374'
    >>> instance.annotations["org.ommx.miplib.url"]
    'https://miplib.zib.de/instance_details_air05.html'
    >>> instance.annotations["org.ommx.miplib.tags"]
    'benchmark,binary,benchmark_suitable,set_partitioning'

    """
    ...

def miplib2017_instance_annotations() -> dict[str, dict[str, str]]:
    """
    Return MIPLIB 2017 instance annotations.

    >>> from ommx.dataset import miplib2017_instance_annotations
    >>> annotations = miplib2017_instance_annotations()
    >>> sorted(annotations.keys())
    ['10teams', ..., 'air05', ...]
    >>> annotations["air05"]["org.ommx.miplib.status"]
    'easy'

    """
    ...


```

### mps

```python
"""
This type stub file was generated by pyright.
"""

from .v1 import Instance

"""
This type stub file was generated by pyright.
"""
def load_file(path: str) -> Instance:
    ...

def write_file(instance: Instance, path: str):
    """
    Outputs the instance as an MPS file.

    - The outputted file is compressed by gzip.
    - Only linear problems are supported.
    - Various forms of metadata, like problem description and variable/constraint names, are not preserved.
    """
    ...


```

### qplib

```python
"""
This type stub file was generated by pyright.
"""

from .v1 import Instance

"""
This type stub file was generated by pyright.
"""
def load_file(path: str) -> Instance:
    ...


```

### testing

```python
"""
This type stub file was generated by pyright.
"""

import enum
from ommx.v1 import Instance
from ommx.v1.solution_pb2 import State

"""
This type stub file was generated by pyright.
"""
class DataType(enum.Enum):
    INT = ...
    FLOAT = ...


class SingleFeasibleLPGenerator:
    INT_LOWER_BOUND = ...
    INT_UPPER_BOUND = ...
    FLOAT_LOWER_BOUND = ...
    FLOAT_UPPER_BOUND = ...
    def __init__(self, n: int, data_type: DataType) -> None:
        """
        The class generates a test instance as follows:

        Objective function: 0
        Constraints: A @ x = b    (A: regular matrix, b: constant vector)

        So the generated instance has a unique solution `x`.

        Args:
            n (int): The size of the matrix and the vectors.
            data_type (DataType): The data type of the matrix and the vectors.

        Raises:
            ValueError: If `n` is not a positive integer or `data_type` is not DataType.
        """
        ...
    
    def get_v1_instance(self) -> Instance:
        """
        Get an instance of a linear programming problem with a unique solution.

        Examples:
            >>> from ommx.testing import DataType, SingleFeasibleLPGenerator
            >>> generator = SingleFeasibleLPGenerator(3, DataType.INT)
            >>> ommx_instance = generator.get_v1_instance()
        """
        ...
    
    def get_v1_state(self) -> State:
        """
        Get the solution state of the generated instance.

        Examples:
            >>> from ommx.testing import DataType, SingleFeasibleLPGenerator
            >>> generator = SingleFeasibleLPGenerator(3, DataType.INT)
            >>> ommx_state = generator.get_v1_state()
        """
        ...
    



```

### v1.__init__

```python
"""
This type stub file was generated by pyright.
"""

from typing import Iterable, Mapping, Optional, overload
from typing_extensions import TypeAlias, Union, deprecated
from dataclasses import dataclass, field
from pandas import DataFrame, NA, Series
from abc import ABC, abstractmethod
from .solution_pb2 import Optimality, Relaxation, Solution as _Solution, State
from .instance_pb2 import Instance as _Instance, Parameters
from .function_pb2 import Function as _Function
from .quadratic_pb2 import Quadratic as _Quadratic
from .polynomial_pb2 import Monomial as _Monomial, Polynomial as _Polynomial
from .linear_pb2 import Linear as _Linear
from .constraint_pb2 import Constraint as _Constraint, Equality, RemovedConstraint as _RemovedConstraint
from .decision_variables_pb2 import Bound, DecisionVariable as _DecisionVariable
from .parametric_instance_pb2 import Parameter as _Parameter, ParametricInstance as _ParametricInstance
from .sample_set_pb2 import SampleSet as _SampleSet, SampledConstraint as _SampledConstraint, SampledValues as _SampledValues, Samples
from .annotation import UserAnnotationBase, datetime_annotation_property, int_annotation_property, json_annotation_property, str_annotation_property, str_list_annotation_property
from .. import _ommx_rust

"""
This type stub file was generated by pyright.
"""
__all__ = ["Instance", "ParametricInstance", "Solution", "Constraint", "SampleSet", "DecisionVariable", "Parameter", "Linear", "Quadratic", "Polynomial", "Function", "State", "Samples", "Parameters", "Optimality", "Relaxation", "Bound", "SampledValues", "ToState", "ToSamples"]
ToState: TypeAlias = Union[State, Mapping[int, float]]
def to_state(state: ToState) -> State:
    ...

ToSamples: TypeAlias = Union[Samples, Mapping[int, ToState], list[ToState]]
def to_samples(samples: ToSamples) -> Samples:
    ...

class InstanceBase(ABC):
    @abstractmethod
    def get_decision_variables(self) -> list[DecisionVariable]:
        ...
    
    @abstractmethod
    def get_constraints(self) -> list[Constraint]:
        ...
    
    @abstractmethod
    def get_removed_constraints(self) -> list[RemovedConstraint]:
        ...
    
    def get_decision_variable(self, variable_id: int) -> DecisionVariable:
        """
        Get a decision variable by ID.
        """
        ...
    
    def get_constraint(self, constraint_id: int) -> Constraint:
        """
        Get a constraint by ID.
        """
        ...
    
    def get_removed_constraint(self, removed_constraint_id: int) -> RemovedConstraint:
        """
        Get a removed constraint by ID.
        """
        ...
    
    @property
    def decision_variables(self) -> DataFrame:
        ...
    
    @property
    def constraints(self) -> DataFrame:
        ...
    
    @property
    def removed_constraints(self) -> DataFrame:
        ...
    


@dataclass
class Instance(InstanceBase, UserAnnotationBase):
    """
    Idiomatic wrapper of ``ommx.v1.Instance`` protobuf message.

    Note that this class also contains annotations like :py:attr:`title` which are not contained in protobuf message but stored in OMMX artifact.
    These annotations are loaded from annotations while reading from OMMX artifact.

    Examples
    =========

    Create an instance for KnapSack Problem

    .. doctest::

        >>> from ommx.v1 import Instance, DecisionVariable

        Profit and weight of items

        >>> p = [10, 13, 18, 31, 7, 15]
        >>> w = [11, 15, 20, 35, 10, 33]

        Decision variables

        >>> x = [DecisionVariable.binary(i) for i in range(6)]

        Objective and constraint

        >>> objective = sum(p[i] * x[i] for i in range(6))
        >>> constraint = sum(w[i] * x[i] for i in range(6)) <= 47

        Compose as an instance

        >>> instance = Instance.from_components(
        ...     decision_variables=x,
        ...     objective=objective,
        ...     constraints=[constraint],
        ...     sense=Instance.MAXIMIZE,
        ... )

    """
    raw: _Instance
    annotations: dict[str, str] = ...
    annotation_namespace = ...
    title = ...
    license = ...
    dataset = ...
    authors = ...
    num_variables = ...
    num_constraints = ...
    created = ...
    MAXIMIZE = ...
    MINIMIZE = ...
    Description = _Instance.Description
    @staticmethod
    def empty() -> Instance:
        """
        Create trivial empty instance of minimization with zero objective, no constraints, and no decision variables.
        """
        ...
    
    @staticmethod
    def from_components(*, objective: int | float | DecisionVariable | Linear | Quadratic | Polynomial | _Function, constraints: Iterable[Constraint | _Constraint], sense: _Instance.Sense.ValueType, decision_variables: Iterable[DecisionVariable | _DecisionVariable], description: Optional[_Instance.Description] = ...) -> Instance:
        ...
    
    @staticmethod
    def load_mps(path: str) -> Instance:
        ...
    
    def write_mps(self, path: str):
        """
        Outputs the instance as an MPS file.

        - The outputted file is compressed by gzip.
        - Only linear problems are supported.
        - Various forms of metadata, like problem description and variable/constraint names, are not preserved.
        """
        ...
    
    @staticmethod
    def load_qplib(path: str) -> Instance:
        ...
    
    def add_user_annotation(self, key: str, value: str, *, annotation_namespace: str = ...):
        """
        Add a user annotation to the instance.

        Examples
        =========

        .. doctest::

                >>> instance = Instance.empty()
                >>> instance.add_user_annotation("author", "Alice")
                >>> instance.get_user_annotations()
                {'author': 'Alice'}
                >>> instance.annotations
                {'org.ommx.user.author': 'Alice'}

        """
        ...
    
    def get_user_annotation(self, key: str, *, annotation_namespace: str = ...):
        """
        Get a user annotation from the instance.

        Examples
        =========

        .. doctest::

                >>> instance = Instance.empty()
                >>> instance.add_user_annotation("author", "Alice")
                >>> instance.get_user_annotation("author")
                'Alice'

        """
        ...
    
    def get_user_annotations(self, *, annotation_namespace: str = ...) -> dict[str, str]:
        """
        Get user annotations from the instance.

        See also :py:meth:`add_user_annotation`.
        """
        ...
    
    @staticmethod
    def from_bytes(data: bytes) -> Instance:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    
    @property
    def description(self) -> _Instance.Description:
        ...
    
    @property
    def objective(self) -> Function:
        ...
    
    @property
    def sense(self) -> _Instance.Sense.ValueType:
        ...
    
    def get_decision_variables(self) -> list[DecisionVariable]:
        """
        Get decision variables as a list of :class:`DecisionVariable` instances.
        """
        ...
    
    def get_constraints(self) -> list[Constraint]:
        """
        Get constraints as a list of :class:`Constraint` instances.
        """
        ...
    
    def get_removed_constraints(self) -> list[RemovedConstraint]:
        """
        Get removed constraints as a list of :class:`RemovedConstraint` instances.
        """
        ...
    
    def evaluate(self, state: ToState) -> Solution:
        ...
    
    def partial_evaluate(self, state: ToState) -> Instance:
        ...
    
    def as_minimization_problem(self):
        """
        Convert the instance to a minimization problem.

        If the instance is already a minimization problem, this does nothing.

        Examples
        =========

        .. doctest::

            >>> from ommx.v1 import Instance, DecisionVariable
            >>> x = [DecisionVariable.binary(i) for i in range(3)]
            >>> instance = Instance.from_components(
            ...     decision_variables=x,
            ...     objective=sum(x),
            ...     constraints=[sum(x) == 1],
            ...     sense=Instance.MAXIMIZE,
            ... )
            >>> instance.sense == Instance.MAXIMIZE
            True
            >>> instance.objective
            Function(x0 + x1 + x2)

            Convert to a minimization problem

            >>> instance.as_minimization_problem()
            >>> instance.sense == Instance.MINIMIZE
            True
            >>> instance.objective
            Function(-x0 - x1 - x2)

        """
        ...
    
    def as_qubo_format(self) -> tuple[dict[tuple[int, int], float], float]:
        """
        Convert unconstrained quadratic instance to PyQUBO-style format.

        This method is designed for better composability rather than easy-to-use.
        This does not execute any conversion of the instance, only translates the data format.
        """
        ...
    
    def as_pubo_format(self) -> dict[tuple[int, ...], float]:
        """
        Convert unconstrained polynomial instance to simple PUBO format.

        This method is designed for better composability rather than easy-to-use.
        This does not execute any conversion of the instance, only translates the data format.
        """
        ...
    
    def penalty_method(self) -> ParametricInstance:
        r"""
        Convert to a parametric unconstrained instance by penalty method.

        Roughly, this converts a constrained problem

        .. math::

            \begin{align*}
                \min_x & \space f(x) & \\
                \text{ s.t. } & \space g_i(x) = 0 & (\forall i)
            \end{align*}

        to an unconstrained problem with parameters

        .. math::

            \min_x f(x) + \sum_i \lambda_i g_i(x)^2

        where :math:`\lambda_i` are the penalty weight parameters for each constraint.
        If you want to use single weight parameter, use :py:meth:`uniform_penalty_method` instead.

        The removed constrains are stored in :py:attr:`~ParametricInstance.removed_constraints`.

        :raises RuntimeError: If the instance contains inequality constraints.

        Examples
        =========

        .. doctest::

            >>> from ommx.v1 import Instance, DecisionVariable, Constraint
            >>> x = [DecisionVariable.binary(i) for i in range(3)]
            >>> instance = Instance.from_components(
            ...     decision_variables=x,
            ...     objective=sum(x),
            ...     constraints=[x[0] + x[1] == 1, x[1] + x[2] == 1],
            ...     sense=Instance.MAXIMIZE,
            ... )
            >>> instance.objective
            Function(x0 + x1 + x2)

            >>> pi = instance.penalty_method()

            The constraint is put in `removed_constraints`

            >>> pi.get_constraints()
            []
            >>> len(pi.get_removed_constraints())
            2
            >>> pi.get_removed_constraints()[0]
            RemovedConstraint(Function(x0 + x1 - 1) == 0, reason=penalty_method, parameter_id=3)
            >>> pi.get_removed_constraints()[1]
            RemovedConstraint(Function(x1 + x2 - 1) == 0, reason=penalty_method, parameter_id=4)

            There are two parameters corresponding to the two constraints

            >>> len(pi.get_parameters())
            2
            >>> p1 = pi.get_parameters()[0]
            >>> p1.id, p1.name
            (3, 'penalty_weight')
            >>> p2 = pi.get_parameters()[1]
            >>> p2.id, p2.name
            (4, 'penalty_weight')

            Substitute all parameters to zero to get the original objective

            >>> instance0 = pi.with_parameters({p1.id: 0.0, p2.id: 0.0})
            >>> instance0.objective
            Function(x0 + x1 + x2)

            Substitute all parameters to one

            >>> instance1 = pi.with_parameters({p1.id: 1.0, p2.id: 1.0})
            >>> instance1.objective
            Function(x0*x0 + 2*x0*x1 + 2*x1*x1 + 2*x1*x2 + x2*x2 - x0 - 3*x1 - x2 + 2)

        """
        ...
    
    def uniform_penalty_method(self) -> ParametricInstance:
        r"""
        Convert to a parametric unconstrained instance by penalty method with uniform weight.

        Roughly, this converts a constrained problem

        .. math::

            \begin{align*}
                \min_x & \space f(x) & \\
                \text{ s.t. } & \space g_i(x) = 0 & (\forall i)
            \end{align*}

        to an unconstrained problem with a parameter

        .. math::

            \min_x f(x) + \lambda \sum_i g_i(x)^2

        where :math:`\lambda` is the uniform penalty weight parameter for all constraints.

        The removed constrains are stored in :py:attr:`~ParametricInstance.removed_constraints`.

        :raises RuntimeError: If the instance contains inequality constraints.

        Examples
        =========

        .. doctest::

            >>> from ommx.v1 import Instance, DecisionVariable
            >>> x = [DecisionVariable.binary(i) for i in range(3)]
            >>> instance = Instance.from_components(
            ...     decision_variables=x,
            ...     objective=sum(x),
            ...     constraints=[sum(x) == 3],
            ...     sense=Instance.MAXIMIZE,
            ... )
            >>> instance.objective
            Function(x0 + x1 + x2)

            >>> pi = instance.uniform_penalty_method()

            The constraint is put in `removed_constraints`

            >>> pi.get_constraints()
            []
            >>> len(pi.get_removed_constraints())
            1
            >>> pi.get_removed_constraints()[0]
            RemovedConstraint(Function(x0 + x1 + x2 - 3) == 0, reason=uniform_penalty_method)

            There is only one parameter in the instance

            >>> len(pi.get_parameters())
            1
            >>> p = pi.get_parameters()[0]
            >>> p.id
            3
            >>> p.name
            'uniform_penalty_weight'

            Substitute `p = 0` to get the original objective

            >>> instance0 = pi.with_parameters({p.id: 0.0})
            >>> instance0.objective
            Function(x0 + x1 + x2)

            Substitute `p = 1`

            >>> instance1 = pi.with_parameters({p.id: 1.0})
            >>> instance1.objective
            Function(x0*x0 + 2*x0*x1 + 2*x0*x2 + x1*x1 + 2*x1*x2 + x2*x2 - 5*x0 - 5*x1 - 5*x2 + 9)

        """
        ...
    
    def as_parametric_instance(self) -> ParametricInstance:
        """
        Convert the instance to a :class:`ParametricInstance`.
        """
        ...
    
    def evaluate_samples(self, samples: ToSamples) -> SampleSet:
        """
        Evaluate the instance with multiple states.
        """
        ...
    
    def relax_constraint(self, constraint_id: int, reason: str, **parameters):
        """
        Remove a constraint from the instance. The removed constraint is stored in :py:attr:`~Instance.removed_constraints`, and can be restored by :py:meth:`restore_constraint`.

        :param constraint_id: The ID of the constraint to remove.
        :param reason: The reason why the constraint is removed.
        :param parameters: Additional parameters to describe the reason.

        Examples
        =========

        Relax constraint, and restore it.

        .. doctest::

            >>> from ommx.v1 import Instance, DecisionVariable
            >>> x = [DecisionVariable.binary(i) for i in range(3)]
            >>> instance = Instance.from_components(
            ...     decision_variables=x,
            ...     objective=sum(x),
            ...     constraints=[(sum(x) == 3).set_id(1)],
            ...     sense=Instance.MAXIMIZE,
            ... )
            >>> instance.get_constraints()
            [Constraint(Function(x0 + x1 + x2 - 3) == 0)]

            >>> instance.relax_constraint(1, "manual relaxation")
            >>> instance.get_constraints()
            []
            >>> instance.get_removed_constraints()
            [RemovedConstraint(Function(x0 + x1 + x2 - 3) == 0, reason=manual relaxation)]

            >>> instance.restore_constraint(1)
            >>> instance.get_constraints()
            [Constraint(Function(x0 + x1 + x2 - 3) == 0)]
            >>> instance.get_removed_constraints()
            []

        Evaluate relaxed instance, and show :py:attr:`~Solution.feasible_unrelaxed`.

        .. doctest::

            >>> from ommx.v1 import Instance, DecisionVariable
            >>> x = [DecisionVariable.binary(i) for i in range(3)]
            >>> instance = Instance.from_components(
            ...     decision_variables=x,
            ...     objective=sum(x),
            ...     constraints=[
            ...         (x[0] + x[1] == 2).set_id(0),
            ...         (x[1] + x[2] == 2).set_id(1),
            ...     ],
            ...     sense=Instance.MINIMIZE,
            ... )

            For x0=0, x1=1, x2=1
            - x0 + x1 == 2 is not feasible
            - x1 + x2 == 2 is feasible

            >>> solution = instance.evaluate({0: 0, 1: 1, 2: 1})
            >>> solution.feasible_relaxed
            False
            >>> solution.feasible_unrelaxed
            False

            Relax the constraint: x0 + x1 == 2

            >>> instance.relax_constraint(0, "testing")
            >>> solution = instance.evaluate({0: 0, 1: 1, 2: 1})
            >>> solution.feasible_relaxed
            True
            >>> solution.feasible_unrelaxed
            False

        """
        ...
    
    def restore_constraint(self, constraint_id: int):
        """
        Restore a removed constraint to the instance.

        :param constraint_id: The ID of the constraint to restore.

        Note that this drops the removed reason and associated parameters. See :py:meth:`relax_constraint` for details.
        """
        ...
    


@dataclass
class ParametricInstance(InstanceBase, UserAnnotationBase):
    """
    Idiomatic wrapper of ``ommx.v1.ParametricInstance`` protobuf message.

    Examples
    =========

    Create an instance for KnapSack Problem with parameters

    .. doctest::

        >>> from ommx.v1 import ParametricInstance, DecisionVariable, Parameter

        Decision variables

        >>> x = [DecisionVariable.binary(i, name="x", subscripts=[i]) for i in range(6)]

        Profit and weight of items as parameters

        >>> p = [Parameter.new(id=i+6, name="Profit", subscripts=[i]) for i in range(6)]
        >>> w = [Parameter.new(id=i+12, name="Weight", subscripts=[i]) for i in range(6)]
        >>> W = Parameter.new(id=18, name="Capacity")

        Objective and constraint

        >>> objective = sum(p[i] * x[i] for i in range(6))
        >>> constraint = sum(w[i] * x[i] for i in range(6)) <= W

        Compose as an instance

        >>> parametric_instance = ParametricInstance.from_components(
        ...     decision_variables=x,
        ...     parameters=p + w + [W],
        ...     objective=objective,
        ...     constraints=[constraint],
        ...     sense=Instance.MAXIMIZE,
        ... )

        Substitute parameters to get an instance

        >>> p_values = { x.id: value for x, value in zip(p, [10, 13, 18, 31, 7, 15]) }
        >>> w_values = { x.id: value for x, value in zip(w, [11, 15, 20, 35, 10, 33]) }
        >>> W_value = { W.id: 47 }
        >>> instance = parametric_instance.with_parameters({**p_values, **w_values, **W_value})

    """
    raw: _ParametricInstance
    annotations: dict[str, str] = ...
    annotation_namespace = ...
    title = ...
    license = ...
    dataset = ...
    authors = ...
    num_variables = ...
    num_constraints = ...
    created = ...
    @staticmethod
    def empty() -> ParametricInstance:
        """
        Create trivial empty instance of minimization with zero objective, no constraints, and no decision variables and parameters.
        """
        ...
    
    @staticmethod
    def from_components(*, objective: int | float | DecisionVariable | Linear | Quadratic | Polynomial | _Function, constraints: Iterable[Constraint | _Constraint], sense: _Instance.Sense.ValueType, decision_variables: Iterable[DecisionVariable | _DecisionVariable], parameters: Iterable[Parameter | _Parameter], description: Optional[_Instance.Description] = ...) -> ParametricInstance:
        ...
    
    @staticmethod
    def from_bytes(data: bytes) -> ParametricInstance:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    
    def get_decision_variables(self) -> list[DecisionVariable]:
        """
        Get decision variables as a list of :class:`DecisionVariable` instances.
        """
        ...
    
    def get_constraints(self) -> list[Constraint]:
        """
        Get constraints as a list of :class:`Constraint
        """
        ...
    
    def get_removed_constraints(self) -> list[RemovedConstraint]:
        """
        Get removed constraints as a list of :class:`RemovedConstraint` instances.
        """
        ...
    
    def get_parameters(self) -> list[Parameter]:
        """
        Get parameters as a list of :class:`Parameter`.
        """
        ...
    
    def get_parameter(self, parameter_id: int) -> Parameter:
        """
        Get a parameter by ID.
        """
        ...
    
    @property
    def parameters(self) -> DataFrame:
        ...
    
    def with_parameters(self, parameters: Parameters | Mapping[int, float]) -> Instance:
        """
        Substitute parameters to yield an instance.
        """
        ...
    


class VariableBase(ABC):
    @property
    @abstractmethod
    def id(self) -> int:
        ...
    
    def __add__(self, other: int | float | VariableBase) -> Linear:
        ...
    
    def __sub__(self, other) -> Linear:
        ...
    
    def __neg__(self) -> Linear:
        ...
    
    def __radd__(self, other) -> Linear:
        ...
    
    def __rsub__(self, other) -> Linear:
        ...
    
    @overload
    def __mul__(self, other: int | float) -> Linear:
        ...
    
    @overload
    def __mul__(self, other: VariableBase) -> Quadratic:
        ...
    
    def __mul__(self, other: int | float | VariableBase) -> Linear | Quadratic:
        ...
    
    def __rmul__(self, other):
        ...
    
    def __le__(self, other) -> Constraint:
        ...
    
    def __ge__(self, other) -> Constraint:
        ...
    
    def __req__(self, other) -> Constraint:
        ...
    
    def __rle__(self, other) -> Constraint:
        ...
    
    def __rge__(self, other) -> Constraint:
        ...
    


@dataclass
class Parameter(VariableBase):
    """
    Idiomatic wrapper of ``ommx.v1.Parameter`` protobuf message.
    """
    raw: _Parameter
    @staticmethod
    def new(id: int, *, name: Optional[str] = ..., subscripts: Iterable[int] = ..., description: Optional[str] = ...):
        ...
    
    @staticmethod
    def from_bytes(data: bytes) -> Parameter:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    
    @property
    def id(self) -> int:
        ...
    
    @property
    def name(self) -> str:
        ...
    
    @property
    def subscripts(self) -> list[int]:
        ...
    
    @property
    def description(self) -> str:
        ...
    
    @property
    def parameters(self) -> dict[str, str]:
        ...
    
    def equals_to(self, other: Parameter) -> bool:
        """
        Alternative to ``==`` operator to compare two decision variables.
        """
        ...
    
    def __eq__(self, other) -> Constraint:
        ...
    


@dataclass
class Solution(UserAnnotationBase):
    """
    Idiomatic wrapper of ``ommx.v1.Solution`` protobuf message.

    This also contains annotations not contained in protobuf message, and will be stored in OMMX artifact.
    """
    raw: _Solution
    annotation_namespace = ...
    instance = ...
    solver = ...
    parameters = ...
    start = ...
    end = ...
    annotations: dict[str, str] = ...
    @staticmethod
    def from_bytes(data: bytes) -> Solution:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    
    @property
    def state(self) -> State:
        ...
    
    @property
    def objective(self) -> float:
        ...
    
    @property
    def decision_variables(self) -> DataFrame:
        ...
    
    @property
    def constraints(self) -> DataFrame:
        ...
    
    def extract_decision_variables(self, name: str) -> dict[tuple[int, ...], float]:
        """
        Extract the values of decision variables based on the `name` with `subscripts` key.

        :raises ValueError: If the decision variable with parameters is found, or if the same subscript is found.

        Examples
        =========

        .. doctest::

            >>> from ommx.v1 import Instance, DecisionVariable
            >>> x = [DecisionVariable.binary(i, name="x", subscripts=[i]) for i in range(3)]
            >>> instance = Instance.from_components(
            ...     decision_variables=x,
            ...     objective=sum(x),
            ...     constraints=[sum(x) == 1],
            ...     sense=Instance.MAXIMIZE,
            ... )
            >>> solution = instance.evaluate({i: 1 for i in range(3)})
            >>> solution.extract_decision_variables("x")
            {(0,): 1.0, (1,): 1.0, (2,): 1.0}

        """
        ...
    
    def extract_constraints(self, name: str) -> dict[tuple[int, ...], float]:
        """
        Extract the values of constraints based on the `name` with `subscripts` key.

        :raises ValueError: If the constraint with parameters is found, or if the same subscript is found.

        Examples
        =========

        .. doctest::

            >>> from ommx.v1 import Instance, DecisionVariable
            >>> x = [DecisionVariable.binary(i) for i in range(3)]
            >>> c0 = (x[0] + x[1] == 1).add_name("c").add_subscripts([0])
            >>> c1 = (x[1] + x[2] == 1).add_name("c").add_subscripts([1])
            >>> instance = Instance.from_components(
            ...     decision_variables=x,
            ...     objective=sum(x),
            ...     constraints=[c0, c1],
            ...     sense=Instance.MAXIMIZE,
            ... )
            >>> solution = instance.evaluate({0: 1, 1: 0, 2: 1})
            >>> solution.extract_constraints("c")
            {(0,): 0.0, (1,): 0.0}

        """
        ...
    
    @property
    def feasible(self) -> bool:
        """
        Feasibility of the solution in terms of all constraints, including :py:attr:`~Instance.removed_constraints`.

        This is an alias for :py:attr:`~Solution.feasible_unrelaxed`.

        Compatibility
        -------------
        The meaning of this property has changed from Python SDK 1.7.0.
        Previously, this property represents the feasibility of the remaining constraints only, i.e. excluding relaxed constraints.
        From Python SDK 1.7.0, this property represents the feasibility of all constraints, including relaxed constraints.
        """
        ...
    
    @property
    def feasible_relaxed(self) -> bool:
        """
        Feasibility of the solution in terms of remaining constraints, not including relaxed (removed) constraints.
        """
        ...
    
    @property
    def feasible_unrelaxed(self) -> bool:
        """
        Feasibility of the solution in terms of all constraints, including relaxed (removed) constraints.
        """
        ...
    
    @property
    def optimality(self) -> Optimality.ValueType:
        ...
    
    @property
    def relaxation(self) -> Relaxation.ValueType:
        ...
    


@dataclass
class DecisionVariable(VariableBase):
    """
    Idiomatic wrapper of ``ommx.v1.DecisionVariable`` protobuf message.

    Note that this object overloads `==` for creating a constraint, not for equality comparison for better integration to mathematical programming.

    >>> x = DecisionVariable.integer(1)
    >>> x == 1
    Constraint(...)

    To compare two objects, use :py:meth:`equals_to` method.

    >>> y = DecisionVariable.integer(2)
    >>> x.equals_to(y)
    False

    """
    raw: _DecisionVariable
    Kind = _DecisionVariable.Kind.ValueType
    BINARY = ...
    INTEGER = ...
    CONTINUOUS = ...
    SEMI_INTEGER = ...
    SEMI_CONTINUOUS = ...
    @staticmethod
    def from_bytes(data: bytes) -> DecisionVariable:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    
    @staticmethod
    def of_type(kind: Kind, id: int, *, lower: float, upper: float, name: Optional[str] = ..., subscripts: Optional[list[int]] = ..., parameters: Optional[dict[str, str]] = ..., description: Optional[str] = ...) -> DecisionVariable:
        ...
    
    @staticmethod
    def binary(id: int, *, name: Optional[str] = ..., subscripts: Optional[list[int]] = ..., parameters: Optional[dict[str, str]] = ..., description: Optional[str] = ...) -> DecisionVariable:
        ...
    
    @staticmethod
    def integer(id: int, *, lower: float = ..., upper: float = ..., name: Optional[str] = ..., subscripts: Optional[list[int]] = ..., parameters: Optional[dict[str, str]] = ..., description: Optional[str] = ...) -> DecisionVariable:
        ...
    
    @staticmethod
    def continuous(id: int, *, lower: float = ..., upper: float = ..., name: Optional[str] = ..., subscripts: Optional[list[int]] = ..., parameters: Optional[dict[str, str]] = ..., description: Optional[str] = ...) -> DecisionVariable:
        ...
    
    @staticmethod
    def semi_integer(id: int, *, lower: float = ..., upper: float = ..., name: Optional[str] = ..., subscripts: Optional[list[int]] = ..., parameters: Optional[dict[str, str]] = ..., description: Optional[str] = ...) -> DecisionVariable:
        ...
    
    @staticmethod
    def semi_continuous(id: int, *, lower: float = ..., upper: float = ..., name: Optional[str] = ..., subscripts: Optional[list[int]] = ..., parameters: Optional[dict[str, str]] = ..., description: Optional[str] = ...) -> DecisionVariable:
        ...
    
    @property
    def id(self) -> int:
        ...
    
    @property
    def name(self) -> str:
        ...
    
    @property
    def kind(self) -> Kind:
        ...
    
    @property
    def bound(self) -> Bound:
        ...
    
    @property
    def subscripts(self) -> list[int]:
        ...
    
    @property
    def parameters(self) -> dict[str, str]:
        ...
    
    @property
    def description(self) -> str:
        ...
    
    def equals_to(self, other: DecisionVariable) -> bool:
        """
        Alternative to ``==`` operator to compare two decision variables.
        """
        ...
    
    def __eq__(self, other) -> Constraint:
        ...
    


class AsConstraint(ABC):
    def __le__(self, other) -> Constraint:
        ...
    
    def __ge__(self, other) -> Constraint:
        ...
    
    def __req__(self, other) -> Constraint:
        ...
    
    def __rle__(self, other) -> Constraint:
        ...
    
    def __rge__(self, other) -> Constraint:
        ...
    


@dataclass
class Linear(AsConstraint):
    """
    Modeler API for linear function

    This is a wrapper of :class:`linear_pb2.Linear` protobuf message.

    Examples
    =========

    .. doctest::

        Create a linear function :math:`f(x_1, x_2) = 2 x_1 + 3 x_2 + 1`
        >>> f = Linear(terms={1: 2, 2: 3}, constant=1)

        Or create via DecisionVariable
        >>> x1 = DecisionVariable.integer(1)
        >>> x2 = DecisionVariable.integer(2)
        >>> g = 2*x1 + 3*x2 + 1

        Compare two linear functions are equal in terms of a polynomial with tolerance
        >>> assert f.almost_equal(g, atol=1e-12)

        Note that `f == g` becomes an equality `Constraint`
        >>> assert isinstance(f == g, Constraint)

    """
    raw: _Linear
    def __init__(self, *, terms: dict[int, float | int], constant: float | int = ...) -> None:
        ...
    
    @staticmethod
    def from_raw(raw: _Linear) -> Linear:
        ...
    
    @property
    def linear_terms(self) -> dict[int, float]:
        """
        Get the terms of the linear function as a dictionary
        """
        ...
    
    @property
    def terms(self) -> dict[tuple[int, ...], float]:
        """
        Linear terms and constant as a dictionary
        """
        ...
    
    @property
    def constant(self) -> float:
        """
        Get the constant term of the linear function
        """
        ...
    
    @staticmethod
    def from_bytes(data: bytes) -> Linear:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    
    @deprecated("Use almost_equal method instead.")
    def equals_to(self, other: Linear) -> bool:
        """
        Alternative to ``==`` operator to compare two linear functions.
        """
        ...
    
    def almost_equal(self, other: Linear, *, atol: float = ...) -> bool:
        """
        Compare two linear functions have almost equal coefficients and constant.
        """
        ...
    
    def evaluate(self, state: ToState) -> tuple[float, set]:
        """
        Evaluate the linear function with the given state.

        Examples
        =========

        .. doctest::

            Evaluate `2 x1 + 3 x2 + 1` with `x1 = 3, x2 = 4, x3 = 5`

            >>> f = Linear(terms={1: 2, 2: 3}, constant=1)
            >>> value, used_ids = f.evaluate({1: 3, 2: 4, 3: 5}) # Unused ID `3` can be included

            2*3 + 3*4 + 1 = 19
            >>> value
            19.0

            Since the value of ID `3` of `state` is not used, the it is not included in `used_ids`.
            >>> used_ids
            {1, 2}

            Missing ID raises an error
            >>> f.evaluate({1: 3})
            Traceback (most recent call last):
            ...
            RuntimeError: Variable id (2) is not found in the solution

        """
        ...
    
    def partial_evaluate(self, state: ToState) -> tuple[Linear, set]:
        """
        Partially evaluate the linear function with the given state.

        Examples
        =========

        .. doctest::

            Evaluate `2 x1 + 3 x2 + 1` with `x1 = 3`, yielding `3 x2 + 7`

            >>> f = Linear(terms={1: 2, 2: 3}, constant=1)
            >>> new_f, used_ids = f.partial_evaluate({1: 3})
            >>> new_f
            Linear(3*x2 + 7)
            >>> used_ids
            {1}
            >>> new_f.partial_evaluate({2: 4})
            (Linear(19), {2})

        """
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __add__(self, other: int | float | DecisionVariable | Linear) -> Linear:
        ...
    
    def __radd__(self, other):
        ...
    
    def __sub__(self, other: int | float | DecisionVariable | Linear) -> Linear:
        ...
    
    def __rsub__(self, other):
        ...
    
    @overload
    def __mul__(self, other: int | float) -> Linear:
        ...
    
    @overload
    def __mul__(self, other: DecisionVariable | Linear) -> Quadratic:
        ...
    
    def __mul__(self, other: int | float | DecisionVariable | Linear) -> Linear | Quadratic:
        ...
    
    def __rmul__(self, other):
        ...
    
    def __neg__(self) -> Linear:
        ...
    
    def __eq__(self, other) -> Constraint:
        ...
    


@dataclass
class Quadratic(AsConstraint):
    raw: _Quadratic
    def __init__(self, *, columns: Iterable[int], rows: Iterable[int], values: Iterable[float | int], linear: Optional[Linear] = ...) -> None:
        ...
    
    @staticmethod
    def from_raw(raw: _Quadratic) -> Quadratic:
        ...
    
    @staticmethod
    def from_bytes(data: bytes) -> Quadratic:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    
    def almost_equal(self, other: Quadratic, *, atol: float = ...) -> bool:
        """
        Compare two quadratic functions have almost equal coefficients
        """
        ...
    
    def evaluate(self, state: ToState) -> tuple[float, set]:
        """
        Evaluate the quadratic function with the given state.

        Examples
        =========

        .. doctest::

            Evaluate `2 x1 x2 + 3 x2 x3 + 1` with `x1 = 3, x2 = 4, x3 = 5`

            >>> x1 = DecisionVariable.integer(1)
            >>> x2 = DecisionVariable.integer(2)
            >>> x3 = DecisionVariable.integer(3)
            >>> f = 2*x1*x2 + 3*x2*x3 + 1
            >>> f
            Quadratic(2*x1*x2 + 3*x2*x3 + 1)

            >>> f.evaluate({1: 3, 2: 4, 3: 5})
            (85.0, {1, 2, 3})

            Missing ID raises an error
            >>> f.evaluate({1: 3})
            Traceback (most recent call last):
            ...
            RuntimeError: Variable id (2) is not found in the solution

        """
        ...
    
    def partial_evaluate(self, state: ToState) -> tuple[Quadratic, set]:
        """
        Partially evaluate the quadratic function with the given state.

        Examples
        =========

        .. doctest::

            Evaluate `2 x1 x2 + 3 x2 x3 + 1` with `x1 = 3`, yielding `3 x2 x3 + 6 x2 + 1`

            >>> x1 = DecisionVariable.integer(1)
            >>> x2 = DecisionVariable.integer(2)
            >>> x3 = DecisionVariable.integer(3)
            >>> f = 2*x1*x2 + 3*x2*x3 + 1
            >>> f
            Quadratic(2*x1*x2 + 3*x2*x3 + 1)

            >>> f.partial_evaluate({1: 3})
            (Quadratic(3*x2*x3 + 6*x2 + 1), {1})

        """
        ...
    
    @property
    def linear(self) -> Linear | None:
        ...
    
    @property
    def quad_terms(self) -> dict[tuple[int, int], float]:
        ...
    
    @property
    def terms(self) -> dict[tuple[int, ...], float]:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __add__(self, other: int | float | DecisionVariable | Linear | Quadratic) -> Quadratic:
        ...
    
    def __radd__(self, other):
        ...
    
    def __sub__(self, other: int | float | DecisionVariable | Linear | Quadratic) -> Quadratic:
        ...
    
    def __rsub__(self, other):
        ...
    
    @overload
    def __mul__(self, other: int | float) -> Quadratic:
        ...
    
    @overload
    def __mul__(self, other: DecisionVariable | Linear | Quadratic) -> Polynomial:
        ...
    
    def __mul__(self, other: int | float | DecisionVariable | Linear | Quadratic) -> Quadratic | Polynomial:
        ...
    
    def __rmul__(self, other):
        ...
    
    def __neg__(self) -> Linear:
        ...
    
    def __eq__(self, other) -> Constraint:
        ...
    


@dataclass
class Polynomial(AsConstraint):
    raw: _Polynomial
    def __init__(self, *, terms: dict[Iterable[int], float | int] = ...) -> None:
        ...
    
    @staticmethod
    def from_raw(raw: _Polynomial) -> Polynomial:
        ...
    
    @staticmethod
    def from_bytes(data: bytes) -> Polynomial:
        ...
    
    @property
    def terms(self) -> dict[tuple[int, ...], float]:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    
    def almost_equal(self, other: Polynomial, *, atol: float = ...) -> bool:
        """
        Compare two polynomial have almost equal coefficients
        """
        ...
    
    def evaluate(self, state: ToState) -> tuple[float, set]:
        """
        Evaluate the polynomial with the given state.

        Examples
        =========

        .. doctest::

            Evaluate `2 x1 x2 x3 + 3 x2 x3 + 1` with `x1 = 3, x2 = 4, x3 = 5`

            >>> x1 = DecisionVariable.integer(1)
            >>> x2 = DecisionVariable.integer(2)
            >>> x3 = DecisionVariable.integer(3)
            >>> f = 2*x1*x2*x3 + 3*x2*x3 + 1
            >>> f
            Polynomial(2*x1*x2*x3 + 3*x2*x3 + 1)

            >>> f.evaluate({1: 3, 2: 4, 3: 5})
            (181.0, {1, 2, 3})

            Missing ID raises an error
            >>> f.evaluate({1: 3})
            Traceback (most recent call last):
            ...
            RuntimeError: Variable id (2) is not found in the solution

        """
        ...
    
    def partial_evaluate(self, state: ToState) -> tuple[Polynomial, set]:
        """
        Partially evaluate the polynomial with the given state.

        Examples
        =========

        .. doctest::

            Evaluate `2 x1 x2 x3 + 3 x2 x3 + 1` with `x1 = 3`, yielding `9 x2 x3 + 1`

            >>> x1 = DecisionVariable.integer(1)
            >>> x2 = DecisionVariable.integer(2)
            >>> x3 = DecisionVariable.integer(3)
            >>> f = 2*x1*x2*x3 + 3*x2*x3 + 1
            >>> f
            Polynomial(2*x1*x2*x3 + 3*x2*x3 + 1)

            >>> f.partial_evaluate({1: 3})
            (Polynomial(9*x2*x3 + 1), {1})

        """
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __add__(self, other: int | float | DecisionVariable | Linear | Quadratic | Polynomial) -> Polynomial:
        ...
    
    def __radd__(self, other):
        ...
    
    def __sub__(self, other: int | float | DecisionVariable | Linear | Quadratic | Polynomial) -> Polynomial:
        ...
    
    def __rsub__(self, other):
        ...
    
    def __mul__(self, other: int | float | DecisionVariable | Linear | Quadratic | Polynomial) -> Polynomial:
        ...
    
    def __rmul__(self, other):
        ...
    
    def __neg__(self) -> Linear:
        ...
    
    def __eq__(self, other) -> Constraint:
        ...
    


def as_function(f: int | float | DecisionVariable | Linear | Quadratic | Polynomial | _Function | Function) -> _Function:
    ...

@dataclass
class Function(AsConstraint):
    raw: _Function
    def __init__(self, inner: int | float | DecisionVariable | Linear | Quadratic | Polynomial | _Function) -> None:
        ...
    
    @property
    def terms(self) -> dict[tuple[int, ...], float]:
        ...
    
    @staticmethod
    def from_bytes(data: bytes) -> Function:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    
    def almost_equal(self, other: Function, *, atol: float = ...) -> bool:
        """
        Compare two functions have almost equal coefficients as a polynomial
        """
        ...
    
    def evaluate(self, state: ToState) -> tuple[float, set]:
        """
        Evaluate the function with the given state.

        Examples
        =========

        .. doctest::

            Evaluate `2 x1 x2 + 3 x2 x3 + 1` with `x1 = 3, x2 = 4, x3 = 5`

            >>> x1 = DecisionVariable.integer(1)
            >>> x2 = DecisionVariable.integer(2)
            >>> x3 = DecisionVariable.integer(3)
            >>> f = Function(2*x1*x2 + 3*x2*x3 + 1)
            >>> f
            Function(2*x1*x2 + 3*x2*x3 + 1)

            >>> f.evaluate({1: 3, 2: 4, 3: 5})
            (85.0, {1, 2, 3})

            Missing ID raises an error
            >>> f.evaluate({1: 3})
            Traceback (most recent call last):
            ...
            RuntimeError: Variable id (2) is not found in the solution

        """
        ...
    
    def partial_evaluate(self, state: ToState) -> tuple[Function, set]:
        """
        Partially evaluate the function with the given state.

        Examples
        =========

        .. doctest::

            Evaluate `2 x1 x2 + 3 x2 x3 + 1` with `x1 = 3`, yielding `3 x2 x3 + 6 x2 + 1`

            >>> x1 = DecisionVariable.integer(1)
            >>> x2 = DecisionVariable.integer(2)
            >>> x3 = DecisionVariable.integer(3)
            >>> f = Function(2*x1*x2 + 3*x2*x3 + 1)
            >>> f
            Function(2*x1*x2 + 3*x2*x3 + 1)

            >>> f.partial_evaluate({1: 3})
            (Function(3*x2*x3 + 6*x2 + 1), {1})

        """
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __add__(self, other: int | float | DecisionVariable | Linear | Quadratic | Polynomial | Function) -> Function:
        ...
    
    def __radd__(self, other):
        ...
    
    def __sub__(self, other: int | float | DecisionVariable | Linear | Quadratic | Polynomial | Function) -> Function:
        ...
    
    def __rsub__(self, other):
        ...
    
    def __mul__(self, other: int | float | DecisionVariable | Linear | Quadratic | Polynomial | Function) -> Function:
        ...
    
    def __rmul__(self, other):
        ...
    
    def __neg__(self) -> Function:
        ...
    
    def __eq__(self, other) -> Constraint:
        ...
    


@dataclass
class Constraint:
    """
    Constraints

    Examples
    =========

    .. doctest::

        >>> x = DecisionVariable.integer(1)
        >>> y = DecisionVariable.integer(2)
        >>> x + y == 1
        Constraint(Function(x1 + x2 - 1) == 0)

        To set the name or other attributes, use methods like :py:meth:`add_name`.

        >>> (x + y <= 5).add_name("constraint 1")
        Constraint(Function(x1 + x2 - 5) <= 0)

    """
    raw: _Constraint
    _counter: int = ...
    EQUAL_TO_ZERO = ...
    LESS_THAN_OR_EQUAL_TO_ZERO = ...
    def __init__(self, *, function: int | float | DecisionVariable | Linear | Quadratic | Polynomial | Function, equality: Equality.ValueType, id: Optional[int] = ..., name: Optional[str] = ..., description: Optional[str] = ..., subscripts: Optional[list[int]] = ..., parameters: Optional[dict[str, str]] = ...) -> None:
        ...
    
    @staticmethod
    def from_raw(raw: _Constraint) -> Constraint:
        ...
    
    @staticmethod
    def from_bytes(data: bytes) -> Constraint:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    
    def set_id(self, id: int) -> Constraint:
        """
        Overwrite the constraint ID.
        """
        ...
    
    def add_name(self, name: str) -> Constraint:
        ...
    
    def add_description(self, description: str) -> Constraint:
        ...
    
    def add_subscripts(self, subscripts: list[int]) -> Constraint:
        ...
    
    def add_parameters(self, parameters: dict[str, str]) -> Constraint:
        ...
    
    @property
    def function(self) -> Function:
        ...
    
    @property
    def id(self) -> int:
        ...
    
    @property
    def equality(self) -> Equality.ValueType:
        ...
    
    @property
    def name(self) -> str | None:
        ...
    
    @property
    def description(self) -> str | None:
        ...
    
    @property
    def subscripts(self) -> list[int]:
        ...
    
    @property
    def parameters(self) -> dict[str, str]:
        ...
    
    def __repr__(self) -> str:
        ...
    


@dataclass
class RemovedConstraint:
    """
    Constraints removed while preprocessing
    """
    raw: _RemovedConstraint
    def __repr__(self) -> str:
        ...
    
    @property
    def equality(self) -> Equality.ValueType:
        ...
    
    @property
    def id(self) -> int:
        ...
    
    @property
    def function(self) -> Function:
        ...
    
    @property
    def name(self) -> str | None:
        ...
    
    @property
    def description(self) -> str | None:
        ...
    
    @property
    def subscripts(self) -> list[int]:
        ...
    
    @property
    def parameters(self) -> dict[str, str]:
        ...
    
    @property
    def removed_reason(self) -> str:
        ...
    
    @property
    def removed_reason_parameters(self) -> dict[str, str]:
        ...
    


@dataclass
class SampleSet(UserAnnotationBase):
    r"""
    The output of sampling-based optimization algorithms, e.g. simulated annealing (SA).

    - Similar to :class:`Solution` rather than :class:`solution_pb2.State`.
      This class contains the sampled values of decision variables with the objective value, constraint violations,
      feasibility, and metadata of constraints and decision variables.
    - This class is usually created via :meth:`Instance.evaluate_samples`.

    Examples
    =========

    Let's consider a simple optimization problem:

    .. math::

        \begin{align*}
            \max &\quad x_1 + 2 x_2 + 3 x_3 \\
            \text{s.t.} &\quad x_1 + x_2 + x_3 = 1 \\
            &\quad x_1, x_2, x_3 \in \{0, 1\}
        \end{align*}

    .. doctest::

        >>> x = [DecisionVariable.binary(i) for i in range(3)]
        >>> instance = Instance.from_components(
        ...     decision_variables=x,
        ...     objective=x[0] + 2*x[1] + 3*x[2],
        ...     constraints=[sum(x) == 1],
        ...     sense=Instance.MAXIMIZE,
        ... )

    with three samples:

    .. doctest::

        >>> samples = {
        ...     0: {0: 1, 1: 0, 2: 0},  # x1 = 1, x2 = x3 = 0
        ...     1: {0: 0, 1: 0, 2: 1},  # x3 = 1, x1 = x2 = 0
        ...     2: {0: 1, 1: 1, 2: 0},  # x1 = x2 = 1, x3 = 0 (infeasible)
        ... } # ^ sample ID

    Note that this will be done by sampling-based solvers, but we do it manually here.
    We can evaluate the samples with via :meth:`Instance.evaluate_samples`:

    .. doctest::

        >>> sample_set = instance.evaluate_samples(samples)
        >>> sample_set.summary  # doctest: +NORMALIZE_WHITESPACE
                   objective  feasible
        sample_id                     
        1                3.0      True
        0                1.0      True
        2                3.0     False

    The :attr:`summary` attribute shows the objective value, feasibility of each sample.
    Note that this `feasible` column represents the feasibility of the original constraints, not the relaxed constraints.
    You can get each samples by :meth:`get` as a :class:`Solution` format:

    .. doctest::

        >>> solution = sample_set.get(sample_id=0)
        >>> solution.objective
        1.0
        >>> solution.decision_variables  # doctest: +NORMALIZE_WHITESPACE
              kind  lower  upper  name subscripts description substituted_value  value
        id
        0   binary    0.0    1.0  <NA>         []        <NA>              <NA>    1.0
        1   binary    0.0    1.0  <NA>         []        <NA>              <NA>    0.0
        2   binary    0.0    1.0  <NA>         []        <NA>              <NA>    0.0

    :meth:`best_feasible` returns the best feasible sample, i.e. the largest objective value among feasible samples:

    .. doctest::

        >>> solution = sample_set.best_feasible()
        >>> solution.objective
        3.0
        >>> solution.decision_variables  # doctest: +NORMALIZE_WHITESPACE
              kind  lower  upper  name subscripts description substituted_value  value
        id                                                                            
        0   binary    0.0    1.0  <NA>         []        <NA>              <NA>    0.0
        1   binary    0.0    1.0  <NA>         []        <NA>              <NA>    0.0
        2   binary    0.0    1.0  <NA>         []        <NA>              <NA>    1.0

    Of course, the sample of smallest objective value is returned for minimization problems.

    """
    raw: _SampleSet
    annotation_namespace = ...
    instance = ...
    solver = ...
    parameters = ...
    start = ...
    end = ...
    annotations: dict[str, str] = ...
    @staticmethod
    def from_bytes(data: bytes) -> SampleSet:
        ...
    
    def to_bytes(self) -> bytes:
        ...
    
    @property
    def summary(self) -> DataFrame:
        ...
    
    @property
    def summary_with_constraints(self) -> DataFrame:
        ...
    
    @property
    def feasible(self) -> dict[int, bool]:
        """
        Feasibility in terms of the original constraints, an alias to :attr:`feasible_unrelaxed`.

        Compatibility
        -------------
        The meaning of this property has changed from Python SDK 1.7.0.
        Previously, this property represents the feasibility of the remaining constraints only, i.e. excluding relaxed constraints.
        From Python SDK 1.7.0, this property represents the feasibility of all constraints, including relaxed constraints.
        """
        ...
    
    @property
    def feasible_relaxed(self) -> dict[int, bool]:
        """
        Feasibility in terms of the remaining (non-removed) constraints.

        For each `sample_id`, this property shows whether the sample is feasible for the all :attr:`Instance.constraints`
        """
        ...
    
    @property
    def feasible_unrelaxed(self) -> dict[int, bool]:
        """
        Feasibility in terms of the original constraints without relaxation.

        For each `sample_id`, this property shows whether the sample is feasible
        both for the all :attr:`Instance.constraints` and all :attr:`Instance.removed_constraints`.
        """
        ...
    
    @property
    def objectives(self) -> dict[int, float]:
        ...
    
    @property
    def sample_ids(self) -> list[int]:
        ...
    
    @property
    def decision_variables(self) -> DataFrame:
        ...
    
    @property
    def constraints(self) -> DataFrame:
        ...
    
    def extract_decision_variables(self, name: str, sample_id: int) -> dict[tuple[int, ...], float]:
        """
        Extract sampled decision variable values for a given name and sample ID.
        """
        ...
    
    def extract_constraints(self, name: str, sample_id: int) -> dict[tuple[int, ...], float]:
        """
        Extract evaluated constraint violations for a given constraint name and sample ID.
        """
        ...
    
    def get(self, sample_id: int) -> Solution:
        """
        Get a sample for a given ID as a solution format
        """
        ...
    
    def best_feasible(self) -> Solution:
        """
        Get the best feasible solution
        """
        ...
    
    def best_feasible_unrelaxed(self) -> Solution:
        """
        Get the best feasible solution without relaxation
        """
        ...
    


@dataclass
class SampledValues:
    raw: _SampledValues
    def as_series(self) -> Series:
        ...
    
    def __iter__(self):
        ...
    
    def __getitem__(self, sample_id: int) -> float:
        ...
    
    def __repr__(self) -> str:
        ...
    



```

### v1.annotation

```python
"""
This type stub file was generated by pyright.
"""

from abc import ABC

"""
This type stub file was generated by pyright.
"""
class UserAnnotationBase(ABC):
    def add_user_annotation(self, key: str, value: str, *, annotation_namespace: str = ...):
        ...
    
    def add_user_annotations(self, annotations: dict[str, str], *, annotation_namespace: str = ...):
        ...
    
    def get_user_annotation(self, key: str, *, annotation_namespace: str = ...):
        ...
    
    def get_user_annotations(self, *, annotation_namespace: str = ...) -> dict[str, str]:
        ...
    


def str_annotation_property(name: str):
    ...

def str_list_annotation_property(name: str):
    ...

def int_annotation_property(name: str):
    ...

def datetime_annotation_property(name: str):
    ...

def json_annotation_property(name: str):
    ...


```

### v1.constraint_hints_pb2

```python
"""
This type stub file was generated by pyright.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import ommx.v1.one_hot_pb2
import ommx.v1.sos1_pb2
import typing

"""
This type stub file was generated by pyright.
"""
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor
@typing.final
class ConstraintHints(google.protobuf.message.Message):
    """A constraint hint is an additional inforomation to be used by solver to gain performance.
    They are derived from one-or-more constraints in the instance and typically contains information of special types of constraints (e.g. one-hot, SOS, ...).
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ONE_HOT_CONSTRAINTS_FIELD_NUMBER: builtins.int
    SOS1_CONSTRAINTS_FIELD_NUMBER: builtins.int
    @property
    def one_hot_constraints(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[ommx.v1.one_hot_pb2.OneHot]:
        """One-hot constraint: e.g. `x_1 + ... + x_n = 1` for binary variables `x_1, ..., x_n`."""
        ...
    
    @property
    def sos1_constraints(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[ommx.v1.sos1_pb2.SOS1]:
        """SOS1 constraint: at most one of x_1, ..., x_n can be non-zero."""
        ...
    
    def __init__(self, *, one_hot_constraints: collections.abc.Iterable[ommx.v1.one_hot_pb2.OneHot] | None = ..., sos1_constraints: collections.abc.Iterable[ommx.v1.sos1_pb2.SOS1] | None = ...) -> None:
        ...
    
    def ClearField(self, field_name: typing.Literal["one_hot_constraints", b"one_hot_constraints", "sos1_constraints", b"sos1_constraints",]) -> None:
        ...
    


global___ConstraintHints = ConstraintHints

```

### v1.constraint_pb2

```python
"""
This type stub file was generated by pyright.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import ommx.v1.function_pb2
import sys
import typing

"""
This type stub file was generated by pyright.
"""
if sys.version_info >= (3, 10):
    ...
else:
    ...
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor
class _Equality:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ...


class _EqualityEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Equality.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    EQUALITY_UNSPECIFIED: _Equality.ValueType
    EQUALITY_EQUAL_TO_ZERO: _Equality.ValueType
    EQUALITY_LESS_THAN_OR_EQUAL_TO_ZERO: _Equality.ValueType
    ...


class Equality(_Equality, metaclass=_EqualityEnumTypeWrapper):
    """Equality of a constraint."""
    ...


EQUALITY_UNSPECIFIED: Equality.ValueType
EQUALITY_EQUAL_TO_ZERO: Equality.ValueType
EQUALITY_LESS_THAN_OR_EQUAL_TO_ZERO: Equality.ValueType
global___Equality = Equality
@typing.final
class Constraint(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    @typing.final
    class ParametersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(self, *, key: builtins.str = ..., value: builtins.str = ...) -> None:
            ...
        
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    ID_FIELD_NUMBER: builtins.int
    EQUALITY_FIELD_NUMBER: builtins.int
    FUNCTION_FIELD_NUMBER: builtins.int
    SUBSCRIPTS_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    id: builtins.int
    equality: global___Equality.ValueType
    name: builtins.str
    description: builtins.str
    @property
    def function(self) -> ommx.v1.function_pb2.Function:
        ...
    
    @property
    def subscripts(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Integer parameters of the constraint.

        Consider for example a problem constains a series of constraints `x[i, j] + y[i, j] <= 10` for `i = 1, 2, 3` and `j = 4, 5`,
        then 6 = 3x2 `Constraint` messages should be created corresponding to each pair of `i` and `j`.
        The `name` field of this message is intended to be a human-readable name of `x[i, j] + y[i, j] <= 10`,
        and the `subscripts` field is intended to be the value of `[i, j]` like `[1, 5]`.
        """
        ...
    
    @property
    def parameters(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """Key-value parameters of the constraint."""
        ...
    
    def __init__(self, *, id: builtins.int = ..., equality: global___Equality.ValueType = ..., function: ommx.v1.function_pb2.Function | None = ..., subscripts: collections.abc.Iterable[builtins.int] | None = ..., parameters: collections.abc.Mapping[builtins.str, builtins.str] | None = ..., name: builtins.str | None = ..., description: builtins.str | None = ...) -> None:
        ...
    
    def HasField(self, field_name: typing.Literal["_description", b"_description", "_name", b"_name", "description", b"description", "function", b"function", "name", b"name",]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing.Literal["_description", b"_description", "_name", b"_name", "description", b"description", "equality", b"equality", "function", b"function", "id", b"id", "name", b"name", "parameters", b"parameters", "subscripts", b"subscripts",]) -> None:
        ...
    
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_description", b"_description"]) -> typing.Literal["description"] | None:
        ...
    
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_name", b"_name"]) -> typing.Literal["name"] | None:
        ...
    


global___Constraint = Constraint
@typing.final
class EvaluatedConstraint(google.protobuf.message.Message):
    """A constraint evaluated with a state"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    @typing.final
    class ParametersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(self, *, key: builtins.str = ..., value: builtins.str = ...) -> None:
            ...
        
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    @typing.final
    class RemovedReasonParametersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(self, *, key: builtins.str = ..., value: builtins.str = ...) -> None:
            ...
        
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    ID_FIELD_NUMBER: builtins.int
    EQUALITY_FIELD_NUMBER: builtins.int
    EVALUATED_VALUE_FIELD_NUMBER: builtins.int
    USED_DECISION_VARIABLE_IDS_FIELD_NUMBER: builtins.int
    SUBSCRIPTS_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    DUAL_VARIABLE_FIELD_NUMBER: builtins.int
    REMOVED_REASON_FIELD_NUMBER: builtins.int
    REMOVED_REASON_PARAMETERS_FIELD_NUMBER: builtins.int
    id: builtins.int
    equality: global___Equality.ValueType
    evaluated_value: builtins.float
    name: builtins.str
    description: builtins.str
    dual_variable: builtins.float
    removed_reason: builtins.str
    @property
    def used_decision_variable_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """IDs of decision variables used to evalute this constraint"""
        ...
    
    @property
    def subscripts(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Integer parameters of the constraint."""
        ...
    
    @property
    def parameters(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """Key-value parameters of the constraint."""
        ...
    
    @property
    def removed_reason_parameters(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """Detailed parameters why the constraint is removed. This field exists only if this message is evaluated from a removed constraint."""
        ...
    
    def __init__(self, *, id: builtins.int = ..., equality: global___Equality.ValueType = ..., evaluated_value: builtins.float = ..., used_decision_variable_ids: collections.abc.Iterable[builtins.int] | None = ..., subscripts: collections.abc.Iterable[builtins.int] | None = ..., parameters: collections.abc.Mapping[builtins.str, builtins.str] | None = ..., name: builtins.str | None = ..., description: builtins.str | None = ..., dual_variable: builtins.float | None = ..., removed_reason: builtins.str | None = ..., removed_reason_parameters: collections.abc.Mapping[builtins.str, builtins.str] | None = ...) -> None:
        ...
    
    def HasField(self, field_name: typing.Literal["_description", b"_description", "_dual_variable", b"_dual_variable", "_name", b"_name", "_removed_reason", b"_removed_reason", "description", b"description", "dual_variable", b"dual_variable", "name", b"name", "removed_reason", b"removed_reason",]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing.Literal["_description", b"_description", "_dual_variable", b"_dual_variable", "_name", b"_name", "_removed_reason", b"_removed_reason", "description", b"description", "dual_variable", b"dual_variable", "equality", b"equality", "evaluated_value", b"evaluated_value", "id", b"id", "name", b"name", "parameters", b"parameters", "removed_reason", b"removed_reason", "removed_reason_parameters", b"removed_reason_parameters", "subscripts", b"subscripts", "used_decision_variable_ids", b"used_decision_variable_ids",]) -> None:
        ...
    
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_description", b"_description"]) -> typing.Literal["description"] | None:
        ...
    
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_dual_variable", b"_dual_variable"]) -> typing.Literal["dual_variable"] | None:
        ...
    
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_name", b"_name"]) -> typing.Literal["name"] | None:
        ...
    
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_removed_reason", b"_removed_reason"]) -> typing.Literal["removed_reason"] | None:
        ...
    


global___EvaluatedConstraint = EvaluatedConstraint
@typing.final
class RemovedConstraint(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    @typing.final
    class RemovedReasonParametersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(self, *, key: builtins.str = ..., value: builtins.str = ...) -> None:
            ...
        
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    CONSTRAINT_FIELD_NUMBER: builtins.int
    REMOVED_REASON_FIELD_NUMBER: builtins.int
    REMOVED_REASON_PARAMETERS_FIELD_NUMBER: builtins.int
    removed_reason: builtins.str
    @property
    def constraint(self) -> global___Constraint:
        """The removed constraint"""
        ...
    
    @property
    def removed_reason_parameters(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """Arbitrary key-value parameters representing why the constraint was removed.

        This should be human-readable and can be used for debugging.
        """
        ...
    
    def __init__(self, *, constraint: global___Constraint | None = ..., removed_reason: builtins.str = ..., removed_reason_parameters: collections.abc.Mapping[builtins.str, builtins.str] | None = ...) -> None:
        ...
    
    def HasField(self, field_name: typing.Literal["constraint", b"constraint"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing.Literal["constraint", b"constraint", "removed_reason", b"removed_reason", "removed_reason_parameters", b"removed_reason_parameters",]) -> None:
        ...
    


global___RemovedConstraint = RemovedConstraint

```

### v1.decision_variables_pb2

```python
"""
This type stub file was generated by pyright.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

"""
This type stub file was generated by pyright.
"""
if sys.version_info >= (3, 10):
    ...
else:
    ...
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor
@typing.final
class Bound(google.protobuf.message.Message):
    """Upper and lower bound of the decision variable."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    LOWER_FIELD_NUMBER: builtins.int
    UPPER_FIELD_NUMBER: builtins.int
    lower: builtins.float
    upper: builtins.float
    def __init__(self, *, lower: builtins.float = ..., upper: builtins.float = ...) -> None:
        ...
    
    def ClearField(self, field_name: typing.Literal["lower", b"lower", "upper", b"upper"]) -> None:
        ...
    


global___Bound = Bound
@typing.final
class DecisionVariable(google.protobuf.message.Message):
    """Decison variable which mathematical programming solver will optimize.
    It must have its kind, i.e. binary, integer, real or others and unique identifier of 64-bit integer.
    It may have its name and subscripts which are used to identify in modeling tools.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Kind:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ...
    
    
    class _KindEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[DecisionVariable._Kind.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        KIND_UNSPECIFIED: DecisionVariable._Kind.ValueType
        KIND_BINARY: DecisionVariable._Kind.ValueType
        KIND_INTEGER: DecisionVariable._Kind.ValueType
        KIND_CONTINUOUS: DecisionVariable._Kind.ValueType
        KIND_SEMI_INTEGER: DecisionVariable._Kind.ValueType
        KIND_SEMI_CONTINUOUS: DecisionVariable._Kind.ValueType
        ...
    
    
    class Kind(_Kind, metaclass=_KindEnumTypeWrapper):
        """Kind of the decision variable"""
        ...
    
    
    KIND_UNSPECIFIED: DecisionVariable.Kind.ValueType
    KIND_BINARY: DecisionVariable.Kind.ValueType
    KIND_INTEGER: DecisionVariable.Kind.ValueType
    KIND_CONTINUOUS: DecisionVariable.Kind.ValueType
    KIND_SEMI_INTEGER: DecisionVariable.Kind.ValueType
    KIND_SEMI_CONTINUOUS: DecisionVariable.Kind.ValueType
    @typing.final
    class ParametersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(self, *, key: builtins.str = ..., value: builtins.str = ...) -> None:
            ...
        
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    ID_FIELD_NUMBER: builtins.int
    KIND_FIELD_NUMBER: builtins.int
    BOUND_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    SUBSCRIPTS_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    SUBSTITUTED_VALUE_FIELD_NUMBER: builtins.int
    id: builtins.int
    kind: global___DecisionVariable.Kind.ValueType
    name: builtins.str
    description: builtins.str
    substituted_value: builtins.float
    @property
    def bound(self) -> global___Bound:
        """Bound of the decision variable
        If the bound is not specified, the decision variable is considered as unbounded.
        """
        ...
    
    @property
    def subscripts(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Subscripts of the decision variable. e.g. `[1, 3]` for an element of multidimensional deicion variable `x[1, 3]`"""
        ...
    
    @property
    def parameters(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """Additional parameters for decision variables"""
        ...
    
    def __init__(self, *, id: builtins.int = ..., kind: global___DecisionVariable.Kind.ValueType = ..., bound: global___Bound | None = ..., name: builtins.str | None = ..., subscripts: collections.abc.Iterable[builtins.int] | None = ..., parameters: collections.abc.Mapping[builtins.str, builtins.str] | None = ..., description: builtins.str | None = ..., substituted_value: builtins.float | None = ...) -> None:
        ...
    
    def HasField(self, field_name: typing.Literal["_bound", b"_bound", "_description", b"_description", "_name", b"_name", "_substituted_value", b"_substituted_value", "bound", b"bound", "description", b"description", "name", b"name", "substituted_value", b"substituted_value",]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing.Literal["_bound", b"_bound", "_description", b"_description", "_name", b"_name", "_substituted_value", b"_substituted_value", "bound", b"bound", "description", b"description", "id", b"id", "kind", b"kind", "name", b"name", "parameters", b"parameters", "subscripts", b"subscripts", "substituted_value", b"substituted_value",]) -> None:
        ...
    
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_bound", b"_bound"]) -> typing.Literal["bound"] | None:
        ...
    
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_description", b"_description"]) -> typing.Literal["description"] | None:
        ...
    
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_name", b"_name"]) -> typing.Literal["name"] | None:
        ...
    
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_substituted_value", b"_substituted_value"]) -> typing.Literal["substituted_value"] | None:
        ...
    


global___DecisionVariable = DecisionVariable

```

### v1.function_pb2

```python
"""
This type stub file was generated by pyright.
"""

import builtins
import google.protobuf.descriptor
import google.protobuf.message
import ommx.v1.linear_pb2
import ommx.v1.polynomial_pb2
import ommx.v1.quadratic_pb2
import typing

"""
This type stub file was generated by pyright.
"""
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor
@typing.final
class Function(google.protobuf.message.Message):
    """Real-valued multivariate function used for objective function and constraints."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    CONSTANT_FIELD_NUMBER: builtins.int
    LINEAR_FIELD_NUMBER: builtins.int
    QUADRATIC_FIELD_NUMBER: builtins.int
    POLYNOMIAL_FIELD_NUMBER: builtins.int
    constant: builtins.float
    @property
    def linear(self) -> ommx.v1.linear_pb2.Linear:
        """Linear function like `f(x_1, x_2) = 2 x_1 + 3 x_2`"""
        ...
    
    @property
    def quadratic(self) -> ommx.v1.quadratic_pb2.Quadratic:
        """Quadratic function like `f(x_1, x_2) = 4 x_1 x_2 + 5 x_2`"""
        ...
    
    @property
    def polynomial(self) -> ommx.v1.polynomial_pb2.Polynomial:
        """Polynomial like `f(x_1, x_2) = 4 x_1^2 + 5 x_2^3 + 6 x_1 x_2^2 + 7 x_2^2 + 8 x_1 x_2 + 9 x_1 + 10 x_2 + 11`"""
        ...
    
    def __init__(self, *, constant: builtins.float = ..., linear: ommx.v1.linear_pb2.Linear | None = ..., quadratic: ommx.v1.quadratic_pb2.Quadratic | None = ..., polynomial: ommx.v1.polynomial_pb2.Polynomial | None = ...) -> None:
        ...
    
    def HasField(self, field_name: typing.Literal["constant", b"constant", "function", b"function", "linear", b"linear", "polynomial", b"polynomial", "quadratic", b"quadratic",]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing.Literal["constant", b"constant", "function", b"function", "linear", b"linear", "polynomial", b"polynomial", "quadratic", b"quadratic",]) -> None:
        ...
    
    def WhichOneof(self, oneof_group: typing.Literal["function", b"function"]) -> typing.Literal["constant", "linear", "quadratic", "polynomial"] | None:
        ...
    


global___Function = Function

```

### v1.instance_pb2

```python
"""
This type stub file was generated by pyright.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import ommx.v1.constraint_hints_pb2
import ommx.v1.constraint_pb2
import ommx.v1.decision_variables_pb2
import ommx.v1.function_pb2
import sys
import typing

"""
This type stub file was generated by pyright.
"""
if sys.version_info >= (3, 10):
    ...
else:
    ...
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor
@typing.final
class Parameters(google.protobuf.message.Message):
    """A set of parameters for instantiating an optimization problem from a parametric instance"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    @typing.final
    class EntriesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int
        value: builtins.float
        def __init__(self, *, key: builtins.int = ..., value: builtins.float = ...) -> None:
            ...
        
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    ENTRIES_FIELD_NUMBER: builtins.int
    @property
    def entries(self) -> google.protobuf.internal.containers.ScalarMap[builtins.int, builtins.float]:
        ...
    
    def __init__(self, *, entries: collections.abc.Mapping[builtins.int, builtins.float] | None = ...) -> None:
        ...
    
    def ClearField(self, field_name: typing.Literal["entries", b"entries"]) -> None:
        ...
    


global___Parameters = Parameters
@typing.final
class Instance(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Sense:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ...
    
    
    class _SenseEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Instance._Sense.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        SENSE_UNSPECIFIED: Instance._Sense.ValueType
        SENSE_MINIMIZE: Instance._Sense.ValueType
        SENSE_MAXIMIZE: Instance._Sense.ValueType
        ...
    
    
    class Sense(_Sense, metaclass=_SenseEnumTypeWrapper):
        """Other types of constraints will be appended here

        TODO: Add semi-definite constraints to represent SDP
        repeated SemiDefiniteConstraint semi_definite_constraints = ?;

        The sense of this instance
        """
        ...
    
    
    SENSE_UNSPECIFIED: Instance.Sense.ValueType
    SENSE_MINIMIZE: Instance.Sense.ValueType
    SENSE_MAXIMIZE: Instance.Sense.ValueType
    @typing.final
    class Description(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        NAME_FIELD_NUMBER: builtins.int
        DESCRIPTION_FIELD_NUMBER: builtins.int
        AUTHORS_FIELD_NUMBER: builtins.int
        CREATED_BY_FIELD_NUMBER: builtins.int
        name: builtins.str
        description: builtins.str
        created_by: builtins.str
        @property
        def authors(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
            ...
        
        def __init__(self, *, name: builtins.str | None = ..., description: builtins.str | None = ..., authors: collections.abc.Iterable[builtins.str] | None = ..., created_by: builtins.str | None = ...) -> None:
            ...
        
        def HasField(self, field_name: typing.Literal["_created_by", b"_created_by", "_description", b"_description", "_name", b"_name", "created_by", b"created_by", "description", b"description", "name", b"name",]) -> builtins.bool:
            ...
        
        def ClearField(self, field_name: typing.Literal["_created_by", b"_created_by", "_description", b"_description", "_name", b"_name", "authors", b"authors", "created_by", b"created_by", "description", b"description", "name", b"name",]) -> None:
            ...
        
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_created_by", b"_created_by"]) -> typing.Literal["created_by"] | None:
            ...
        
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_description", b"_description"]) -> typing.Literal["description"] | None:
            ...
        
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_name", b"_name"]) -> typing.Literal["name"] | None:
            ...
        
    
    
    @typing.final
    class DecisionVariableDependencyEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int
        @property
        def value(self) -> ommx.v1.function_pb2.Function:
            ...
        
        def __init__(self, *, key: builtins.int = ..., value: ommx.v1.function_pb2.Function | None = ...) -> None:
            ...
        
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool:
            ...
        
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    DESCRIPTION_FIELD_NUMBER: builtins.int
    DECISION_VARIABLES_FIELD_NUMBER: builtins.int
    OBJECTIVE_FIELD_NUMBER: builtins.int
    CONSTRAINTS_FIELD_NUMBER: builtins.int
    SENSE_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    CONSTRAINT_HINTS_FIELD_NUMBER: builtins.int
    REMOVED_CONSTRAINTS_FIELD_NUMBER: builtins.int
    DECISION_VARIABLE_DEPENDENCY_FIELD_NUMBER: builtins.int
    sense: global___Instance.Sense.ValueType
    @property
    def description(self) -> global___Instance.Description:
        ...
    
    @property
    def decision_variables(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[ommx.v1.decision_variables_pb2.DecisionVariable]:
        """Decision variables used in this instance

        - This must constain every decision variables used in the objective and constraints.
        - This can contains a decision variable that is not used in the objective or constraints.
        """
        ...
    
    @property
    def objective(self) -> ommx.v1.function_pb2.Function:
        ...
    
    @property
    def constraints(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[ommx.v1.constraint_pb2.Constraint]:
        """Constraints of the optimization problem"""
        ...
    
    @property
    def parameters(self) -> global___Parameters:
        """Parameters used when instantiating this instance"""
        ...
    
    @property
    def constraint_hints(self) -> ommx.v1.constraint_hints_pb2.ConstraintHints:
        """Constraint hints to be used by solver to gain performance. They are derived from one-or-more constraints in the instance and typically contains information of special types of constraints (e.g. one-hot, SOS, ...)."""
        ...
    
    @property
    def removed_constraints(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[ommx.v1.constraint_pb2.RemovedConstraint]:
        """Constraints removed via preprocessing. These are restored when evaluated into `ommx.v1.Solution`."""
        ...
    
    @property
    def decision_variable_dependency(self) -> google.protobuf.internal.containers.MessageMap[builtins.int, ommx.v1.function_pb2.Function]:
        """When a decision variable is dependent on another decision variable as polynomial, this map contains the ID of the dependent decision variable as key and the polynomial as value."""
        ...
    
    def __init__(self, *, description: global___Instance.Description | None = ..., decision_variables: collections.abc.Iterable[ommx.v1.decision_variables_pb2.DecisionVariable] | None = ..., objective: ommx.v1.function_pb2.Function | None = ..., constraints: collections.abc.Iterable[ommx.v1.constraint_pb2.Constraint] | None = ..., sense: global___Instance.Sense.ValueType = ..., parameters: global___Parameters | None = ..., constraint_hints: ommx.v1.constraint_hints_pb2.ConstraintHints | None = ..., removed_constraints: collections.abc.Iterable[ommx.v1.constraint_pb2.RemovedConstraint] | None = ..., decision_variable_dependency: collections.abc.Mapping[builtins.int, ommx.v1.function_pb2.Function] | None = ...) -> None:
        ...
    
    def HasField(self, field_name: typing.Literal["_parameters", b"_parameters", "constraint_hints", b"constraint_hints", "description", b"description", "objective", b"objective", "parameters", b"parameters",]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing.Literal["_parameters", b"_parameters", "constraint_hints", b"constraint_hints", "constraints", b"constraints", "decision_variable_dependency", b"decision_variable_dependency", "decision_variables", b"decision_variables", "description", b"description", "objective", b"objective", "parameters", b"parameters", "removed_constraints", b"removed_constraints", "sense", b"sense",]) -> None:
        ...
    
    def WhichOneof(self, oneof_group: typing.Literal["_parameters", b"_parameters"]) -> typing.Literal["parameters"] | None:
        ...
    


global___Instance = Instance

```

### v1.linear_pb2

```python
"""
This type stub file was generated by pyright.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing

"""
This type stub file was generated by pyright.
"""
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor
@typing.final
class Linear(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    @typing.final
    class Term(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        ID_FIELD_NUMBER: builtins.int
        COEFFICIENT_FIELD_NUMBER: builtins.int
        id: builtins.int
        coefficient: builtins.float
        def __init__(self, *, id: builtins.int = ..., coefficient: builtins.float = ...) -> None:
            ...
        
        def ClearField(self, field_name: typing.Literal["coefficient", b"coefficient", "id", b"id"]) -> None:
            ...
        
    
    
    TERMS_FIELD_NUMBER: builtins.int
    CONSTANT_FIELD_NUMBER: builtins.int
    constant: builtins.float
    @property
    def terms(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Linear.Term]:
        ...
    
    def __init__(self, *, terms: collections.abc.Iterable[global___Linear.Term] | None = ..., constant: builtins.float = ...) -> None:
        ...
    
    def ClearField(self, field_name: typing.Literal["constant", b"constant", "terms", b"terms"]) -> None:
        ...
    


global___Linear = Linear

```

### v1.one_hot_pb2

```python
"""
This type stub file was generated by pyright.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing

"""
This type stub file was generated by pyright.
"""
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor
@typing.final
class OneHot(google.protobuf.message.Message):
    """A message representing a one-hot constraint."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    CONSTRAINT_ID_FIELD_NUMBER: builtins.int
    DECISION_VARIABLES_FIELD_NUMBER: builtins.int
    constraint_id: builtins.int
    @property
    def decision_variables(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The list of ids of decision variables that are constrained to be one-hot."""
        ...
    
    def __init__(self, *, constraint_id: builtins.int = ..., decision_variables: collections.abc.Iterable[builtins.int] | None = ...) -> None:
        ...
    
    def ClearField(self, field_name: typing.Literal["constraint_id", b"constraint_id", "decision_variables", b"decision_variables",]) -> None:
        ...
    


global___OneHot = OneHot

```

### v1.parametric_instance_pb2

```python
"""
This type stub file was generated by pyright.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import ommx.v1.constraint_hints_pb2
import ommx.v1.constraint_pb2
import ommx.v1.decision_variables_pb2
import ommx.v1.function_pb2
import ommx.v1.instance_pb2
import typing

"""
This type stub file was generated by pyright.
"""
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor
@typing.final
class Parameter(google.protobuf.message.Message):
    """Placeholder of a parameter in a parametrized optimization problem"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    @typing.final
    class ParametersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(self, *, key: builtins.str = ..., value: builtins.str = ...) -> None:
            ...
        
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    SUBSCRIPTS_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    id: builtins.int
    name: builtins.str
    description: builtins.str
    @property
    def subscripts(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Subscripts of the parameter, same usage as DecisionVariable.subscripts"""
        ...
    
    @property
    def parameters(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """Additional metadata for the parameter, same usage as DecisionVariable.parameters"""
        ...
    
    def __init__(self, *, id: builtins.int = ..., name: builtins.str | None = ..., subscripts: collections.abc.Iterable[builtins.int] | None = ..., parameters: collections.abc.Mapping[builtins.str, builtins.str] | None = ..., description: builtins.str | None = ...) -> None:
        ...
    
    def HasField(self, field_name: typing.Literal["_description", b"_description", "_name", b"_name", "description", b"description", "name", b"name",]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing.Literal["_description", b"_description", "_name", b"_name", "description", b"description", "id", b"id", "name", b"name", "parameters", b"parameters", "subscripts", b"subscripts",]) -> None:
        ...
    
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_description", b"_description"]) -> typing.Literal["description"] | None:
        ...
    
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_name", b"_name"]) -> typing.Literal["name"] | None:
        ...
    


global___Parameter = Parameter
@typing.final
class ParametricInstance(google.protobuf.message.Message):
    """Optimization problem including parameter, variables varying while solving the problem like penalty weights or dual variables.
    These parameters are not decision variables.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    @typing.final
    class DecisionVariableDependencyEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int
        @property
        def value(self) -> ommx.v1.function_pb2.Function:
            ...
        
        def __init__(self, *, key: builtins.int = ..., value: ommx.v1.function_pb2.Function | None = ...) -> None:
            ...
        
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool:
            ...
        
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    DESCRIPTION_FIELD_NUMBER: builtins.int
    DECISION_VARIABLES_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    OBJECTIVE_FIELD_NUMBER: builtins.int
    CONSTRAINTS_FIELD_NUMBER: builtins.int
    SENSE_FIELD_NUMBER: builtins.int
    CONSTRAINT_HINTS_FIELD_NUMBER: builtins.int
    REMOVED_CONSTRAINTS_FIELD_NUMBER: builtins.int
    DECISION_VARIABLE_DEPENDENCY_FIELD_NUMBER: builtins.int
    sense: ommx.v1.instance_pb2.Instance.Sense.ValueType
    @property
    def description(self) -> ommx.v1.instance_pb2.Instance.Description:
        ...
    
    @property
    def decision_variables(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[ommx.v1.decision_variables_pb2.DecisionVariable]:
        """Decision variables used in this instance"""
        ...
    
    @property
    def parameters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Parameter]:
        """Parameters of this instance

        - The ID must be unique within the instance including the decision variables.
        """
        ...
    
    @property
    def objective(self) -> ommx.v1.function_pb2.Function:
        """Objective function of the optimization problem. This may contain parameters in addition to the decision variables."""
        ...
    
    @property
    def constraints(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[ommx.v1.constraint_pb2.Constraint]:
        """Constraints of the optimization problem. This may contain parameters in addition to the decision variables."""
        ...
    
    @property
    def constraint_hints(self) -> ommx.v1.constraint_hints_pb2.ConstraintHints:
        """Constraint hints to be used by solver to gain performance. They are derived from one-or-more constraints in the instance and typically contains information of special types of constraints (e.g. one-hot, SOS, ...)."""
        ...
    
    @property
    def removed_constraints(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[ommx.v1.constraint_pb2.RemovedConstraint]:
        """Constraints removed via preprocessing. These are restored when evaluated into `ommx.v1.Solution`."""
        ...
    
    @property
    def decision_variable_dependency(self) -> google.protobuf.internal.containers.MessageMap[builtins.int, ommx.v1.function_pb2.Function]:
        """When a decision variable is dependent on another decision variable as polynomial, this map contains the ID of the dependent decision variable as key and the polynomial as value."""
        ...
    
    def __init__(self, *, description: ommx.v1.instance_pb2.Instance.Description | None = ..., decision_variables: collections.abc.Iterable[ommx.v1.decision_variables_pb2.DecisionVariable] | None = ..., parameters: collections.abc.Iterable[global___Parameter] | None = ..., objective: ommx.v1.function_pb2.Function | None = ..., constraints: collections.abc.Iterable[ommx.v1.constraint_pb2.Constraint] | None = ..., sense: ommx.v1.instance_pb2.Instance.Sense.ValueType = ..., constraint_hints: ommx.v1.constraint_hints_pb2.ConstraintHints | None = ..., removed_constraints: collections.abc.Iterable[ommx.v1.constraint_pb2.RemovedConstraint] | None = ..., decision_variable_dependency: collections.abc.Mapping[builtins.int, ommx.v1.function_pb2.Function] | None = ...) -> None:
        ...
    
    def HasField(self, field_name: typing.Literal["constraint_hints", b"constraint_hints", "description", b"description", "objective", b"objective",]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing.Literal["constraint_hints", b"constraint_hints", "constraints", b"constraints", "decision_variable_dependency", b"decision_variable_dependency", "decision_variables", b"decision_variables", "description", b"description", "objective", b"objective", "parameters", b"parameters", "removed_constraints", b"removed_constraints", "sense", b"sense",]) -> None:
        ...
    


global___ParametricInstance = ParametricInstance

```

### v1.polynomial_pb2

```python
"""
This type stub file was generated by pyright.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing

"""
This type stub file was generated by pyright.
"""
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor
@typing.final
class Monomial(google.protobuf.message.Message):
    """A monomial in a multivariate polynomial."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    IDS_FIELD_NUMBER: builtins.int
    COEFFICIENT_FIELD_NUMBER: builtins.int
    coefficient: builtins.float
    @property
    def ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        ...
    
    def __init__(self, *, ids: collections.abc.Iterable[builtins.int] | None = ..., coefficient: builtins.float = ...) -> None:
        ...
    
    def ClearField(self, field_name: typing.Literal["coefficient", b"coefficient", "ids", b"ids"]) -> None:
        ...
    


global___Monomial = Monomial
@typing.final
class Polynomial(google.protobuf.message.Message):
    """Multi­variate polynomial"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    TERMS_FIELD_NUMBER: builtins.int
    @property
    def terms(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Monomial]:
        ...
    
    def __init__(self, *, terms: collections.abc.Iterable[global___Monomial] | None = ...) -> None:
        ...
    
    def ClearField(self, field_name: typing.Literal["terms", b"terms"]) -> None:
        ...
    


global___Polynomial = Polynomial

```

### v1.quadratic_pb2

```python
"""
This type stub file was generated by pyright.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import ommx.v1.linear_pb2
import typing

"""
This type stub file was generated by pyright.
"""
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor
@typing.final
class Quadratic(google.protobuf.message.Message):
    """Quadratic function as a COO-style sparse matrix and linear sparse vector.

    COOrdinate format, also known as triplet format, is a way to represent sparse matrices as a list of non-zero elements.
    It consists of three lists: the row indices, the column indices, and the values of the non-zero elements with following constraints:

    - Entries and coordinates sorted by row, then column.
    - There are no duplicate entries (i.e. duplicate (i,j) locations)
    - Data arrays MAY have explicit zeros.

    Note that this matrix is not assured to be symmetric nor upper triangular.
    For example, a quadratic function `x1^2 + x2^2 + 2x1*x2` can be represented as:

    - `{ rows: [0, 0, 1], columns: [0, 1, 1], values: [1, 2, 1] }`, i.e. an upper triangular matrix `[[1, 2], [0, 1]`
    - `{ rows: [0, 0, 1, 1], columns: [0, 1, 0, 1], values: [1, 1, 1, 1] }`, i.e. a symmetric matrix `[[1, 1], [1, 1]]`

    or even a non-symmetric, non-trianglar matrix as `x1^2 + 3x1*x2 - x2*x1 + x2^2`:

    - `{ rows: [0, 0, 1, 1], columns: [0, 1, 0, 1], values: [1, 3, -1, 1] }`, i.e. a non-symmetric matrix `[[1, 3], [-1, 1]]`
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ROWS_FIELD_NUMBER: builtins.int
    COLUMNS_FIELD_NUMBER: builtins.int
    VALUES_FIELD_NUMBER: builtins.int
    LINEAR_FIELD_NUMBER: builtins.int
    @property
    def rows(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        ...
    
    @property
    def columns(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        ...
    
    @property
    def values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        ...
    
    @property
    def linear(self) -> ommx.v1.linear_pb2.Linear:
        ...
    
    def __init__(self, *, rows: collections.abc.Iterable[builtins.int] | None = ..., columns: collections.abc.Iterable[builtins.int] | None = ..., values: collections.abc.Iterable[builtins.float] | None = ..., linear: ommx.v1.linear_pb2.Linear | None = ...) -> None:
        ...
    
    def HasField(self, field_name: typing.Literal["_linear", b"_linear", "linear", b"linear"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing.Literal["_linear", b"_linear", "columns", b"columns", "linear", b"linear", "rows", b"rows", "values", b"values",]) -> None:
        ...
    
    def WhichOneof(self, oneof_group: typing.Literal["_linear", b"_linear"]) -> typing.Literal["linear"] | None:
        ...
    


global___Quadratic = Quadratic

```

### v1.sample_set_pb2

```python
"""
This type stub file was generated by pyright.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import ommx.v1.constraint_pb2
import ommx.v1.decision_variables_pb2
import ommx.v1.instance_pb2
import ommx.v1.solution_pb2
import typing

"""
This type stub file was generated by pyright.
"""
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor
@typing.final
class Samples(google.protobuf.message.Message):
    """A map from sample ID to state"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    @typing.final
    class SamplesEntry(google.protobuf.message.Message):
        """Sampling processes are likely to generate same samples multiple times. We compress the same samples into one entry.
        Note that uncompressed state is also valid. The reader should not assume that every states are distinct.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        STATE_FIELD_NUMBER: builtins.int
        IDS_FIELD_NUMBER: builtins.int
        @property
        def state(self) -> ommx.v1.solution_pb2.State:
            """State of the sample"""
            ...
        
        @property
        def ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
            """IDs of the sample"""
            ...
        
        def __init__(self, *, state: ommx.v1.solution_pb2.State | None = ..., ids: collections.abc.Iterable[builtins.int] | None = ...) -> None:
            ...
        
        def HasField(self, field_name: typing.Literal["state", b"state"]) -> builtins.bool:
            ...
        
        def ClearField(self, field_name: typing.Literal["ids", b"ids", "state", b"state"]) -> None:
            ...
        
    
    
    ENTRIES_FIELD_NUMBER: builtins.int
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Samples.SamplesEntry]:
        ...
    
    def __init__(self, *, entries: collections.abc.Iterable[global___Samples.SamplesEntry] | None = ...) -> None:
        ...
    
    def ClearField(self, field_name: typing.Literal["entries", b"entries"]) -> None:
        ...
    


global___Samples = Samples
@typing.final
class SampledValues(google.protobuf.message.Message):
    """A map from sample IDs to sampled values"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    @typing.final
    class SampledValuesEntry(google.protobuf.message.Message):
        """Compressed sampled values, but uncompressed state is also valid. The reader should not assume that every states are distinct."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        VALUE_FIELD_NUMBER: builtins.int
        IDS_FIELD_NUMBER: builtins.int
        value: builtins.float
        @property
        def ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
            """IDs of the sample"""
            ...
        
        def __init__(self, *, value: builtins.float = ..., ids: collections.abc.Iterable[builtins.int] | None = ...) -> None:
            ...
        
        def ClearField(self, field_name: typing.Literal["ids", b"ids", "value", b"value"]) -> None:
            ...
        
    
    
    ENTRIES_FIELD_NUMBER: builtins.int
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SampledValues.SampledValuesEntry]:
        ...
    
    def __init__(self, *, entries: collections.abc.Iterable[global___SampledValues.SampledValuesEntry] | None = ...) -> None:
        ...
    
    def ClearField(self, field_name: typing.Literal["entries", b"entries"]) -> None:
        ...
    


global___SampledValues = SampledValues
@typing.final
class SampledDecisionVariable(google.protobuf.message.Message):
    """A pair of decision variable description and its sampled values"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    DECISION_VARIABLE_FIELD_NUMBER: builtins.int
    SAMPLES_FIELD_NUMBER: builtins.int
    @property
    def decision_variable(self) -> ommx.v1.decision_variables_pb2.DecisionVariable:
        ...
    
    @property
    def samples(self) -> global___SampledValues:
        """Sampled values of decision variable. This becomes `None` if the decision variable is not sampled."""
        ...
    
    def __init__(self, *, decision_variable: ommx.v1.decision_variables_pb2.DecisionVariable | None = ..., samples: global___SampledValues | None = ...) -> None:
        ...
    
    def HasField(self, field_name: typing.Literal["_samples", b"_samples", "decision_variable", b"decision_variable", "samples", b"samples",]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing.Literal["_samples", b"_samples", "decision_variable", b"decision_variable", "samples", b"samples",]) -> None:
        ...
    
    def WhichOneof(self, oneof_group: typing.Literal["_samples", b"_samples"]) -> typing.Literal["samples"] | None:
        ...
    


global___SampledDecisionVariable = SampledDecisionVariable
@typing.final
class SampledConstraint(google.protobuf.message.Message):
    """Evaluated constraint for samples"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    @typing.final
    class ParametersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(self, *, key: builtins.str = ..., value: builtins.str = ...) -> None:
            ...
        
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    @typing.final
    class RemovedReasonParametersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(self, *, key: builtins.str = ..., value: builtins.str = ...) -> None:
            ...
        
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    @typing.final
    class FeasibleEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int
        value: builtins.bool
        def __init__(self, *, key: builtins.int = ..., value: builtins.bool = ...) -> None:
            ...
        
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    ID_FIELD_NUMBER: builtins.int
    EQUALITY_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    SUBSCRIPTS_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    REMOVED_REASON_FIELD_NUMBER: builtins.int
    REMOVED_REASON_PARAMETERS_FIELD_NUMBER: builtins.int
    EVALUATED_VALUES_FIELD_NUMBER: builtins.int
    USED_DECISION_VARIABLE_IDS_FIELD_NUMBER: builtins.int
    FEASIBLE_FIELD_NUMBER: builtins.int
    id: builtins.int
    equality: ommx.v1.constraint_pb2.Equality.ValueType
    name: builtins.str
    description: builtins.str
    removed_reason: builtins.str
    @property
    def subscripts(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Integer parameters of the constraint."""
        ...
    
    @property
    def parameters(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """Key-value parameters of the constraint."""
        ...
    
    @property
    def removed_reason_parameters(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """Detailed parameters why the constraint is removed. This field exists only if this message is evaluated from a removed constraint."""
        ...
    
    @property
    def evaluated_values(self) -> global___SampledValues:
        """Evaluated values of constraint for each sample"""
        ...
    
    @property
    def used_decision_variable_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """IDs of decision variables used to evaluate this constraint"""
        ...
    
    @property
    def feasible(self) -> google.protobuf.internal.containers.ScalarMap[builtins.int, builtins.bool]:
        """Feasibility of each sample"""
        ...
    
    def __init__(self, *, id: builtins.int = ..., equality: ommx.v1.constraint_pb2.Equality.ValueType = ..., name: builtins.str | None = ..., subscripts: collections.abc.Iterable[builtins.int] | None = ..., parameters: collections.abc.Mapping[builtins.str, builtins.str] | None = ..., description: builtins.str | None = ..., removed_reason: builtins.str | None = ..., removed_reason_parameters: collections.abc.Mapping[builtins.str, builtins.str] | None = ..., evaluated_values: global___SampledValues | None = ..., used_decision_variable_ids: collections.abc.Iterable[builtins.int] | None = ..., feasible: collections.abc.Mapping[builtins.int, builtins.bool] | None = ...) -> None:
        ...
    
    def HasField(self, field_name: typing.Literal["_description", b"_description", "_name", b"_name", "_removed_reason", b"_removed_reason", "description", b"description", "evaluated_values", b"evaluated_values", "name", b"name", "removed_reason", b"removed_reason",]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing.Literal["_description", b"_description", "_name", b"_name", "_removed_reason", b"_removed_reason", "description", b"description", "equality", b"equality", "evaluated_values", b"evaluated_values", "feasible", b"feasible", "id", b"id", "name", b"name", "parameters", b"parameters", "removed_reason", b"removed_reason", "removed_reason_parameters", b"removed_reason_parameters", "subscripts", b"subscripts", "used_decision_variable_ids", b"used_decision_variable_ids",]) -> None:
        ...
    
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_description", b"_description"]) -> typing.Literal["description"] | None:
        ...
    
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_name", b"_name"]) -> typing.Literal["name"] | None:
        ...
    
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_removed_reason", b"_removed_reason"]) -> typing.Literal["removed_reason"] | None:
        ...
    


global___SampledConstraint = SampledConstraint
@typing.final
class SampleSet(google.protobuf.message.Message):
    """Output of the sampling process."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    @typing.final
    class FeasibleEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int
        value: builtins.bool
        def __init__(self, *, key: builtins.int = ..., value: builtins.bool = ...) -> None:
            ...
        
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    @typing.final
    class FeasibleUnrelaxedEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int
        value: builtins.bool
        def __init__(self, *, key: builtins.int = ..., value: builtins.bool = ...) -> None:
            ...
        
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    @typing.final
    class FeasibleRelaxedEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int
        value: builtins.bool
        def __init__(self, *, key: builtins.int = ..., value: builtins.bool = ...) -> None:
            ...
        
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    OBJECTIVES_FIELD_NUMBER: builtins.int
    DECISION_VARIABLES_FIELD_NUMBER: builtins.int
    CONSTRAINTS_FIELD_NUMBER: builtins.int
    FEASIBLE_FIELD_NUMBER: builtins.int
    FEASIBLE_UNRELAXED_FIELD_NUMBER: builtins.int
    FEASIBLE_RELAXED_FIELD_NUMBER: builtins.int
    SENSE_FIELD_NUMBER: builtins.int
    sense: ommx.v1.instance_pb2.Instance.Sense.ValueType
    @property
    def objectives(self) -> global___SampledValues:
        ...
    
    @property
    def decision_variables(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SampledDecisionVariable]:
        ...
    
    @property
    def constraints(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SampledConstraint]:
        ...
    
    @property
    def feasible(self) -> google.protobuf.internal.containers.ScalarMap[builtins.int, builtins.bool]:
        """Feasibility for *both* remaining and removed constraints of each sample.

        The meaning of `feasible` field in SDK changes between Python SDK 1.6.0 to 1.7.0.
        In Python SDK 1.6.0, `feasible` represents the feasibility of remaining constraints of each sample,
        i.e. removed constraints (introduced in 1.6.0) are not considered.
        After Python SDK 1.7.0, `feasible` represents the feasibility of all constraints of each sample.
        The feasibility of 1.6.0 is renamed to `feasible_relaxed` in 1.7.0.
        """
        ...
    
    @property
    def feasible_unrelaxed(self) -> google.protobuf.internal.containers.ScalarMap[builtins.int, builtins.bool]:
        """[Deprecated] This field has been introduced in Python SDK 1.6.0 to represent
        the feasibility of all constraints of each sample.
        The `feasible` field is used in this sense after Python SDK 1.7.0.
        """
        ...
    
    @property
    def feasible_relaxed(self) -> google.protobuf.internal.containers.ScalarMap[builtins.int, builtins.bool]:
        """Feasibility for remaining (non-removed) constraints of each sample."""
        ...
    
    def __init__(self, *, objectives: global___SampledValues | None = ..., decision_variables: collections.abc.Iterable[global___SampledDecisionVariable] | None = ..., constraints: collections.abc.Iterable[global___SampledConstraint] | None = ..., feasible: collections.abc.Mapping[builtins.int, builtins.bool] | None = ..., feasible_unrelaxed: collections.abc.Mapping[builtins.int, builtins.bool] | None = ..., feasible_relaxed: collections.abc.Mapping[builtins.int, builtins.bool] | None = ..., sense: ommx.v1.instance_pb2.Instance.Sense.ValueType = ...) -> None:
        ...
    
    def HasField(self, field_name: typing.Literal["objectives", b"objectives"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing.Literal["constraints", b"constraints", "decision_variables", b"decision_variables", "feasible", b"feasible", "feasible_relaxed", b"feasible_relaxed", "feasible_unrelaxed", b"feasible_unrelaxed", "objectives", b"objectives", "sense", b"sense",]) -> None:
        ...
    


global___SampleSet = SampleSet

```

### v1.solution_pb2

```python
"""
This type stub file was generated by pyright.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import ommx.v1.constraint_pb2
import ommx.v1.decision_variables_pb2
import sys
import typing

"""
This type stub file was generated by pyright.
"""
if sys.version_info >= (3, 10):
    ...
else:
    ...
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor
class _Optimality:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ...


class _OptimalityEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Optimality.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    OPTIMALITY_UNSPECIFIED: _Optimality.ValueType
    OPTIMALITY_OPTIMAL: _Optimality.ValueType
    OPTIMALITY_NOT_OPTIMAL: _Optimality.ValueType
    ...


class Optimality(_Optimality, metaclass=_OptimalityEnumTypeWrapper):
    ...


OPTIMALITY_UNSPECIFIED: Optimality.ValueType
OPTIMALITY_OPTIMAL: Optimality.ValueType
OPTIMALITY_NOT_OPTIMAL: Optimality.ValueType
global___Optimality = Optimality
class _Relaxation:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ...


class _RelaxationEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Relaxation.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    RELAXATION_UNSPECIFIED: _Relaxation.ValueType
    RELAXATION_LP_RELAXED: _Relaxation.ValueType
    ...


class Relaxation(_Relaxation, metaclass=_RelaxationEnumTypeWrapper):
    ...


RELAXATION_UNSPECIFIED: Relaxation.ValueType
RELAXATION_LP_RELAXED: Relaxation.ValueType
global___Relaxation = Relaxation
@typing.final
class State(google.protobuf.message.Message):
    """A set of values of decision variables, without any evaluation, even the
    feasiblity of the solution.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    @typing.final
    class EntriesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int
        value: builtins.float
        def __init__(self, *, key: builtins.int = ..., value: builtins.float = ...) -> None:
            ...
        
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    ENTRIES_FIELD_NUMBER: builtins.int
    @property
    def entries(self) -> google.protobuf.internal.containers.ScalarMap[builtins.int, builtins.float]:
        """The value of the solution for each variable ID."""
        ...
    
    def __init__(self, *, entries: collections.abc.Mapping[builtins.int, builtins.float] | None = ...) -> None:
        ...
    
    def ClearField(self, field_name: typing.Literal["entries", b"entries"]) -> None:
        ...
    


global___State = State
@typing.final
class Solution(google.protobuf.message.Message):
    """Solution with evaluated objective and constraints"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    STATE_FIELD_NUMBER: builtins.int
    OBJECTIVE_FIELD_NUMBER: builtins.int
    DECISION_VARIABLES_FIELD_NUMBER: builtins.int
    EVALUATED_CONSTRAINTS_FIELD_NUMBER: builtins.int
    FEASIBLE_FIELD_NUMBER: builtins.int
    FEASIBLE_RELAXED_FIELD_NUMBER: builtins.int
    FEASIBLE_UNRELAXED_FIELD_NUMBER: builtins.int
    OPTIMALITY_FIELD_NUMBER: builtins.int
    RELAXATION_FIELD_NUMBER: builtins.int
    objective: builtins.float
    feasible: builtins.bool
    feasible_relaxed: builtins.bool
    feasible_unrelaxed: builtins.bool
    optimality: global___Optimality.ValueType
    relaxation: global___Relaxation.ValueType
    @property
    def state(self) -> global___State:
        ...
    
    @property
    def decision_variables(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[ommx.v1.decision_variables_pb2.DecisionVariable]:
        ...
    
    @property
    def evaluated_constraints(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[ommx.v1.constraint_pb2.EvaluatedConstraint]:
        ...
    
    def __init__(self, *, state: global___State | None = ..., objective: builtins.float = ..., decision_variables: collections.abc.Iterable[ommx.v1.decision_variables_pb2.DecisionVariable] | None = ..., evaluated_constraints: collections.abc.Iterable[ommx.v1.constraint_pb2.EvaluatedConstraint] | None = ..., feasible: builtins.bool = ..., feasible_relaxed: builtins.bool | None = ..., feasible_unrelaxed: builtins.bool = ..., optimality: global___Optimality.ValueType = ..., relaxation: global___Relaxation.ValueType = ...) -> None:
        ...
    
    def HasField(self, field_name: typing.Literal["_feasible_relaxed", b"_feasible_relaxed", "feasible_relaxed", b"feasible_relaxed", "state", b"state",]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing.Literal["_feasible_relaxed", b"_feasible_relaxed", "decision_variables", b"decision_variables", "evaluated_constraints", b"evaluated_constraints", "feasible", b"feasible", "feasible_relaxed", b"feasible_relaxed", "feasible_unrelaxed", b"feasible_unrelaxed", "objective", b"objective", "optimality", b"optimality", "relaxation", b"relaxation", "state", b"state",]) -> None:
        ...
    
    def WhichOneof(self, oneof_group: typing.Literal["_feasible_relaxed", b"_feasible_relaxed"]) -> typing.Literal["feasible_relaxed"] | None:
        ...
    


global___Solution = Solution
@typing.final
class Infeasible(google.protobuf.message.Message):
    """The solver proved that the problem is infeasible.
    TODO: Add more information about the infeasibility.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    def __init__(self) -> None:
        ...
    


global___Infeasible = Infeasible
@typing.final
class Unbounded(google.protobuf.message.Message):
    """The solver proved that the problem is unbounded.
    TODO: Add more information about the unboundedness.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    def __init__(self) -> None:
        ...
    


global___Unbounded = Unbounded
@typing.final
class Result(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ERROR_FIELD_NUMBER: builtins.int
    SOLUTION_FIELD_NUMBER: builtins.int
    INFEASIBLE_FIELD_NUMBER: builtins.int
    UNBOUNDED_FIELD_NUMBER: builtins.int
    error: builtins.str
    @property
    def solution(self) -> global___Solution:
        """Some feasible or infeasible solution for the problem is found. Most of heuristic solvers should use this value."""
        ...
    
    @property
    def infeasible(self) -> global___Infeasible:
        """The solver proved that the problem is infeasible, i.e. all solutions of the problem are infeasible.
        If the solver cannot get the proof of infeasibility,
        and just cannot find any feasible solution due to the time limit or due to heuristic algorithm limitation,
        the solver should return its *best* `Solution` message with `feasible` field set to `false`.
        """
        ...
    
    @property
    def unbounded(self) -> global___Unbounded:
        """The solver proved that the problem is unbounded."""
        ...
    
    def __init__(self, *, error: builtins.str = ..., solution: global___Solution | None = ..., infeasible: global___Infeasible | None = ..., unbounded: global___Unbounded | None = ...) -> None:
        ...
    
    def HasField(self, field_name: typing.Literal["error", b"error", "infeasible", b"infeasible", "result", b"result", "solution", b"solution", "unbounded", b"unbounded",]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing.Literal["error", b"error", "infeasible", b"infeasible", "result", b"result", "solution", b"solution", "unbounded", b"unbounded",]) -> None:
        ...
    
    def WhichOneof(self, oneof_group: typing.Literal["result", b"result"]) -> typing.Literal["error", "solution", "infeasible", "unbounded"] | None:
        ...
    


global___Result = Result

```

### v1.sos1_pb2

```python
"""
This type stub file was generated by pyright.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing

"""
This type stub file was generated by pyright.
"""
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor
@typing.final
class SOS1(google.protobuf.message.Message):
    """A message representing a [Spcial Ordered Set constraint of Type 1](https://en.wikipedia.org/wiki/Special_ordered_set#Types) (SOS1).
    SOS1 constraint on non-negative variables x_1, ..., x_n
    requires that at most one of x_i can be non-zero.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    BINARY_CONSTRAINT_ID_FIELD_NUMBER: builtins.int
    BIG_M_CONSTRAINT_IDS_FIELD_NUMBER: builtins.int
    DECISION_VARIABLES_FIELD_NUMBER: builtins.int
    binary_constraint_id: builtins.int
    @property
    def big_m_constraint_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The IDs of the big-M constraint on non-binary variables."""
        ...
    
    @property
    def decision_variables(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The list of ids of decision variables that are constrained to be one-hot."""
        ...
    
    def __init__(self, *, binary_constraint_id: builtins.int = ..., big_m_constraint_ids: collections.abc.Iterable[builtins.int] | None = ..., decision_variables: collections.abc.Iterable[builtins.int] | None = ...) -> None:
        ...
    
    def ClearField(self, field_name: typing.Literal["big_m_constraint_ids", b"big_m_constraint_ids", "binary_constraint_id", b"binary_constraint_id", "decision_variables", b"decision_variables",]) -> None:
        ...
    


global___SOS1 = SOS1

```

