# pyright: reportIncompatibleVariableOverride=false
"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import ommx.v1.constraint_pb2
import ommx.v1.decision_variables_pb2
import ommx.v1.instance_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _Optimality:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _OptimalityEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Optimality.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    OPTIMALITY_UNSPECIFIED: _Optimality.ValueType  # 0
    """The solver cannot determine whether the solution is optimal. Most of heuristic solvers should use this value."""
    OPTIMALITY_OPTIMAL: _Optimality.ValueType  # 1
    """The solver has determined that the solution is optimal."""
    OPTIMALITY_NOT_OPTIMAL: _Optimality.ValueType  # 2
    """The solver has determined that the solution is not optimal."""

class Optimality(_Optimality, metaclass=_OptimalityEnumTypeWrapper): ...

OPTIMALITY_UNSPECIFIED: Optimality.ValueType  # 0
"""The solver cannot determine whether the solution is optimal. Most of heuristic solvers should use this value."""
OPTIMALITY_OPTIMAL: Optimality.ValueType  # 1
"""The solver has determined that the solution is optimal."""
OPTIMALITY_NOT_OPTIMAL: Optimality.ValueType  # 2
"""The solver has determined that the solution is not optimal."""
global___Optimality = Optimality

class _Relaxation:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _RelaxationEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Relaxation.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    RELAXATION_UNSPECIFIED: _Relaxation.ValueType  # 0
    """No relaxation is used."""
    RELAXATION_LP_RELAXED: _Relaxation.ValueType  # 1
    """The solution is obtained by a relaxed linear programming problem."""

class Relaxation(_Relaxation, metaclass=_RelaxationEnumTypeWrapper): ...

RELAXATION_UNSPECIFIED: Relaxation.ValueType  # 0
"""No relaxation is used."""
RELAXATION_LP_RELAXED: Relaxation.ValueType  # 1
"""The solution is obtained by a relaxed linear programming problem."""
global___Relaxation = Relaxation

@typing.final
class State(google.protobuf.message.Message):
    """A set of values of decision variables, without any evaluation, even the
    feasiblity of the solution.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class EntriesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int
        value: builtins.float
        def __init__(
            self,
            *,
            key: builtins.int = ...,
            value: builtins.float = ...,
        ) -> None: ...
        def ClearField(
            self, field_name: typing.Literal["key", b"key", "value", b"value"]
        ) -> None: ...

    ENTRIES_FIELD_NUMBER: builtins.int
    @property
    def entries(
        self,
    ) -> google.protobuf.internal.containers.ScalarMap[builtins.int, builtins.float]:
        """The value of the solution for each variable ID."""

    def __init__(
        self,
        *,
        entries: collections.abc.Mapping[builtins.int, builtins.float] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["entries", b"entries"]) -> None: ...

global___State = State

@typing.final
class Solution(google.protobuf.message.Message):
    """Solution with evaluated objective and constraints"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STATE_FIELD_NUMBER: builtins.int
    OBJECTIVE_FIELD_NUMBER: builtins.int
    DECISION_VARIABLES_FIELD_NUMBER: builtins.int
    EVALUATED_CONSTRAINTS_FIELD_NUMBER: builtins.int
    FEASIBLE_FIELD_NUMBER: builtins.int
    FEASIBLE_RELAXED_FIELD_NUMBER: builtins.int
    FEASIBLE_UNRELAXED_FIELD_NUMBER: builtins.int
    OPTIMALITY_FIELD_NUMBER: builtins.int
    RELAXATION_FIELD_NUMBER: builtins.int
    SENSE_FIELD_NUMBER: builtins.int
    objective: builtins.float
    feasible: builtins.bool
    """The feasibility of the solution for all, remaining and removed constraints.

    The feasibility for the remaining constraints is represented by the `feasible_relaxed` field.
    """
    feasible_relaxed: builtins.bool
    """Feasibility of the solution for remaining constraints, ignoring removed constraints.

    This is optional due to the backward compatibility.
    If this field is NULL, the `feasible` field represents relaxed feasibility,
    and the deprecated `feasible_unrelaxed` field represents the feasibility including removed constraints.
    """
    feasible_unrelaxed: builtins.bool
    """[DEPRECATED] Feasibility of the solution for all constraints.
    This field has been introduced in Python SDK 1.6.0 and deprecated in 1.7.0.
    The feasibility in this sense is represented by the `feasible` field after 1.7.0.
    """
    optimality: global___Optimality.ValueType
    """The optimality of the solution."""
    relaxation: global___Relaxation.ValueType
    """Whether the solution is obtained by a relaxed linear programming solver."""
    sense: ommx.v1.instance_pb2.Instance.Sense.ValueType
    """Whether the problem is a minimization or maximization problem."""
    @property
    def state(self) -> global___State: ...
    @property
    def decision_variables(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        ommx.v1.decision_variables_pb2.DecisionVariable
    ]: ...
    @property
    def evaluated_constraints(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        ommx.v1.constraint_pb2.EvaluatedConstraint
    ]: ...
    def __init__(
        self,
        *,
        state: global___State | None = ...,
        objective: builtins.float = ...,
        decision_variables: collections.abc.Iterable[
            ommx.v1.decision_variables_pb2.DecisionVariable
        ]
        | None = ...,
        evaluated_constraints: collections.abc.Iterable[
            ommx.v1.constraint_pb2.EvaluatedConstraint
        ]
        | None = ...,
        feasible: builtins.bool = ...,
        feasible_relaxed: builtins.bool | None = ...,
        feasible_unrelaxed: builtins.bool = ...,
        optimality: global___Optimality.ValueType = ...,
        relaxation: global___Relaxation.ValueType = ...,
        sense: ommx.v1.instance_pb2.Instance.Sense.ValueType = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_feasible_relaxed",
            b"_feasible_relaxed",
            "feasible_relaxed",
            b"feasible_relaxed",
            "state",
            b"state",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_feasible_relaxed",
            b"_feasible_relaxed",
            "decision_variables",
            b"decision_variables",
            "evaluated_constraints",
            b"evaluated_constraints",
            "feasible",
            b"feasible",
            "feasible_relaxed",
            b"feasible_relaxed",
            "feasible_unrelaxed",
            b"feasible_unrelaxed",
            "objective",
            b"objective",
            "optimality",
            b"optimality",
            "relaxation",
            b"relaxation",
            "sense",
            b"sense",
            "state",
            b"state",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["_feasible_relaxed", b"_feasible_relaxed"]
    ) -> typing.Literal["feasible_relaxed"] | None: ...

global___Solution = Solution

@typing.final
class Infeasible(google.protobuf.message.Message):
    """The solver proved that the problem is infeasible.
    TODO: Add more information about the infeasibility.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___Infeasible = Infeasible

@typing.final
class Unbounded(google.protobuf.message.Message):
    """The solver proved that the problem is unbounded.
    TODO: Add more information about the unboundedness.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___Unbounded = Unbounded

@typing.final
class Result(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ERROR_FIELD_NUMBER: builtins.int
    SOLUTION_FIELD_NUMBER: builtins.int
    INFEASIBLE_FIELD_NUMBER: builtins.int
    UNBOUNDED_FIELD_NUMBER: builtins.int
    error: builtins.str
    """Error information by the solver which cannot be expressed by other messages.
    This string should be human-readable.
    """
    @property
    def solution(self) -> global___Solution:
        """Some feasible or infeasible solution for the problem is found. Most of heuristic solvers should use this value."""

    @property
    def infeasible(self) -> global___Infeasible:
        """The solver proved that the problem is infeasible, i.e. all solutions of the problem are infeasible.
        If the solver cannot get the proof of infeasibility,
        and just cannot find any feasible solution due to the time limit or due to heuristic algorithm limitation,
        the solver should return its *best* `Solution` message with `feasible` field set to `false`.
        """

    @property
    def unbounded(self) -> global___Unbounded:
        """The solver proved that the problem is unbounded."""

    def __init__(
        self,
        *,
        error: builtins.str = ...,
        solution: global___Solution | None = ...,
        infeasible: global___Infeasible | None = ...,
        unbounded: global___Unbounded | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "error",
            b"error",
            "infeasible",
            b"infeasible",
            "result",
            b"result",
            "solution",
            b"solution",
            "unbounded",
            b"unbounded",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "error",
            b"error",
            "infeasible",
            b"infeasible",
            "result",
            b"result",
            "solution",
            b"solution",
            "unbounded",
            b"unbounded",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["result", b"result"]
    ) -> typing.Literal["error", "solution", "infeasible", "unbounded"] | None: ...

global___Result = Result
