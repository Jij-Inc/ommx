# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import os
import pathlib
import typing

class ArtifactArchive:
    image_name: typing.Optional[builtins.str]
    annotations: builtins.dict[builtins.str, builtins.str]
    layers: builtins.list[Descriptor]
    @staticmethod
    def from_oci_archive(
        path: builtins.str | os.PathLike | pathlib.Path,
    ) -> ArtifactArchive: ...
    def get_blob(self, digest: builtins.str) -> bytes: ...
    def push(self) -> None: ...

class ArtifactArchiveBuilder:
    @staticmethod
    def new_unnamed(
        path: builtins.str | os.PathLike | pathlib.Path,
    ) -> ArtifactArchiveBuilder: ...
    @staticmethod
    def new(
        path: builtins.str | os.PathLike | pathlib.Path, image_name: builtins.str
    ) -> ArtifactArchiveBuilder: ...
    @staticmethod
    def temp() -> ArtifactArchiveBuilder: ...
    def add_layer(
        self,
        media_type: builtins.str,
        blob: bytes,
        annotations: typing.Mapping[builtins.str, builtins.str],
    ) -> Descriptor: ...
    def add_annotation(self, key: builtins.str, value: builtins.str) -> None: ...
    def build(self) -> ArtifactArchive: ...

class ArtifactDir:
    image_name: typing.Optional[builtins.str]
    annotations: builtins.dict[builtins.str, builtins.str]
    layers: builtins.list[Descriptor]
    @staticmethod
    def from_image_name(image_name: builtins.str) -> ArtifactDir: ...
    @staticmethod
    def from_oci_dir(
        path: builtins.str | os.PathLike | pathlib.Path,
    ) -> ArtifactDir: ...
    def get_blob(self, digest: builtins.str) -> bytes: ...
    def push(self) -> None: ...

class ArtifactDirBuilder:
    @staticmethod
    def new(image_name: builtins.str) -> ArtifactDirBuilder: ...
    @staticmethod
    def for_github(
        org: builtins.str, repo: builtins.str, name: builtins.str, tag: builtins.str
    ) -> ArtifactDirBuilder: ...
    def add_layer(
        self,
        media_type: builtins.str,
        blob: bytes,
        annotations: typing.Mapping[builtins.str, builtins.str],
    ) -> Descriptor: ...
    def add_annotation(self, key: builtins.str, value: builtins.str) -> None: ...
    def build(self) -> ArtifactDir: ...

class Descriptor:
    r"""
    Descriptor of blob in artifact
    """

    digest: builtins.str
    size: builtins.int
    media_type: builtins.str
    annotations: builtins.dict[builtins.str, builtins.str]
    user_annotations: builtins.dict[builtins.str, builtins.str]
    def to_dict(self) -> dict: ...
    @staticmethod
    def from_dict(dict: dict) -> Descriptor: ...
    def to_json(self) -> builtins.str: ...
    @staticmethod
    def from_json(json: builtins.str) -> Descriptor: ...
    def __str__(self) -> builtins.str: ...
    def __eq__(self, rhs: typing.Any) -> builtins.bool: ...

class Function:
    @staticmethod
    def from_scalar(scalar: builtins.float) -> Function: ...
    @staticmethod
    def from_linear(linear: Linear) -> Function: ...
    @staticmethod
    def from_quadratic(quadratic: Quadratic) -> Function: ...
    @staticmethod
    def from_polynomial(polynomial: Polynomial) -> Function: ...
    @staticmethod
    def decode(bytes: bytes) -> Function: ...
    def encode(self) -> bytes: ...
    def almost_equal(self, other: Function, atol: builtins.float) -> builtins.bool: ...
    def __repr__(self) -> builtins.str: ...
    def __add__(self, rhs: Function) -> Function: ...
    def __sub__(self, rhs: Function) -> Function: ...
    def __mul__(self, rhs: Function) -> Function: ...
    def add_scalar(self, scalar: builtins.float) -> Function: ...
    def add_linear(self, linear: Linear) -> Function: ...
    def add_quadratic(self, quadratic: Quadratic) -> Function: ...
    def add_polynomial(self, polynomial: Polynomial) -> Function: ...
    def mul_scalar(self, scalar: builtins.float) -> Function: ...
    def mul_linear(self, linear: Linear) -> Function: ...
    def mul_quadratic(self, quadratic: Quadratic) -> Function: ...
    def mul_polynomial(self, polynomial: Polynomial) -> Function: ...
    def content_factor(self) -> builtins.float: ...

class Instance:
    @staticmethod
    def from_bytes(bytes: bytes) -> Instance: ...
    def to_bytes(self) -> bytes: ...
    def validate(self) -> None: ...
    def as_pubo_format(self) -> dict: ...
    def as_qubo_format(self) -> tuple[dict, builtins.float]: ...
    def as_parametric_instance(self) -> ParametricInstance: ...
    def penalty_method(self) -> ParametricInstance: ...
    def uniform_penalty_method(self) -> ParametricInstance: ...
    def evaluate_samples(self, samples: Samples) -> SampleSet: ...
    def relax_constraint(
        self,
        constraint_id: builtins.int,
        removed_reason: builtins.str,
        removed_reason_parameters: typing.Mapping[builtins.str, builtins.str],
    ) -> None: ...
    def restore_constraint(self, constraint_id: builtins.int) -> None: ...
    def log_encode(self, integer_variable_ids: builtins.set[builtins.int]) -> None: ...
    def convert_inequality_to_equality_with_integer_slack(
        self, constraint_id: builtins.int, max_integer_range: builtins.int
    ) -> None: ...
    def add_integer_slack_to_inequality(
        self, constraint_id: builtins.int, slack_upper_bound: builtins.int
    ) -> typing.Optional[builtins.float]: ...

class Linear:
    @staticmethod
    def single_term(id: builtins.int, coefficient: builtins.float) -> Linear: ...
    @staticmethod
    def decode(bytes: bytes) -> Linear: ...
    def encode(self) -> bytes: ...
    def almost_equal(self, other: Linear, atol: builtins.float) -> builtins.bool: ...
    def __repr__(self) -> builtins.str: ...
    def __add__(self, rhs: Linear) -> Linear: ...
    def __sub__(self, rhs: Linear) -> Linear: ...
    def __mul__(self, rhs: Linear) -> Quadratic: ...
    def add_scalar(self, scalar: builtins.float) -> Linear: ...
    def mul_scalar(self, scalar: builtins.float) -> Linear: ...

class Parameters:
    @staticmethod
    def from_bytes(bytes: bytes) -> Parameters: ...
    def to_bytes(self) -> bytes: ...

class ParametricInstance:
    @staticmethod
    def from_bytes(bytes: bytes) -> ParametricInstance: ...
    def to_bytes(self) -> bytes: ...
    def validate(self) -> None: ...
    def with_parameters(self, parameters: Parameters) -> Instance: ...

class Polynomial:
    @staticmethod
    def decode(bytes: bytes) -> Polynomial: ...
    def encode(self) -> bytes: ...
    def almost_equal(
        self, other: Polynomial, atol: builtins.float
    ) -> builtins.bool: ...
    def __repr__(self) -> builtins.str: ...
    def __add__(self, rhs: Polynomial) -> Polynomial: ...
    def __sub__(self, rhs: Polynomial) -> Polynomial: ...
    def __mul__(self, rhs: Polynomial) -> Polynomial: ...
    def add_scalar(self, scalar: builtins.float) -> Polynomial: ...
    def add_linear(self, linear: Linear) -> Polynomial: ...
    def add_quadratic(self, quadratic: Quadratic) -> Polynomial: ...
    def mul_scalar(self, scalar: builtins.float) -> Polynomial: ...
    def mul_linear(self, linear: Linear) -> Polynomial: ...
    def mul_quadratic(self, quadratic: Quadratic) -> Polynomial: ...

class Quadratic:
    @staticmethod
    def decode(bytes: bytes) -> Quadratic: ...
    def encode(self) -> bytes: ...
    def almost_equal(self, other: Quadratic, atol: builtins.float) -> builtins.bool: ...
    def __repr__(self) -> builtins.str: ...
    def __add__(self, rhs: Quadratic) -> Quadratic: ...
    def __sub__(self, rhs: Quadratic) -> Quadratic: ...
    def __mul__(self, rhs: Quadratic) -> Polynomial: ...
    def add_scalar(self, scalar: builtins.float) -> Quadratic: ...
    def add_linear(self, linear: Linear) -> Quadratic: ...
    def mul_scalar(self, scalar: builtins.float) -> Quadratic: ...
    def mul_linear(self, linear: Linear) -> Polynomial: ...

class SampleSet:
    @staticmethod
    def from_bytes(bytes: bytes) -> SampleSet: ...
    def to_bytes(self) -> bytes: ...
    def get(self, sample_id: builtins.int) -> Solution: ...
    def num_samples(self) -> builtins.int: ...
    def sample_ids(self) -> builtins.set[builtins.int]: ...
    def feasible_ids(self) -> builtins.set[builtins.int]: ...
    def feasible_unrelaxed_ids(self) -> builtins.set[builtins.int]: ...
    def best_feasible(self) -> Solution: ...
    def best_feasible_unrelaxed(self) -> Solution: ...

class Samples:
    @staticmethod
    def from_bytes(bytes: bytes) -> Samples: ...
    def to_bytes(self) -> bytes: ...

class Solution:
    @staticmethod
    def from_bytes(bytes: bytes) -> Solution: ...
    def to_bytes(self) -> bytes: ...

def evaluate_constraint(
    function: bytes, state: bytes
) -> tuple[bytes, builtins.set[builtins.int]]: ...
def evaluate_function(
    function: bytes, state: bytes
) -> tuple[builtins.float, builtins.set[builtins.int]]: ...
def evaluate_instance(
    function: bytes, state: bytes
) -> tuple[bytes, builtins.set[builtins.int]]: ...
def evaluate_linear(
    function: bytes, state: bytes
) -> tuple[builtins.float, builtins.set[builtins.int]]: ...
def evaluate_polynomial(
    function: bytes, state: bytes
) -> tuple[builtins.float, builtins.set[builtins.int]]: ...
def evaluate_quadratic(
    function: bytes, state: bytes
) -> tuple[builtins.float, builtins.set[builtins.int]]: ...
def load_mps_bytes(path: builtins.str) -> bytes: ...
def load_qplib_bytes(path: builtins.str) -> bytes: ...
def miplib2017_instance_annotations() -> builtins.dict[
    builtins.str, builtins.dict[builtins.str, builtins.str]
]: ...
def partial_evaluate_constraint(
    obj: bytes, state: bytes
) -> tuple[bytes, builtins.set[builtins.int]]: ...
def partial_evaluate_function(
    function: bytes, state: bytes
) -> tuple[bytes, builtins.set[builtins.int]]: ...
def partial_evaluate_instance(
    obj: bytes, state: bytes
) -> tuple[bytes, builtins.set[builtins.int]]: ...
def partial_evaluate_linear(
    function: bytes, state: bytes
) -> tuple[bytes, builtins.set[builtins.int]]: ...
def partial_evaluate_polynomial(
    function: bytes, state: bytes
) -> tuple[bytes, builtins.set[builtins.int]]: ...
def partial_evaluate_quadratic(
    function: bytes, state: bytes
) -> tuple[bytes, builtins.set[builtins.int]]: ...
def used_decision_variable_ids(function: bytes) -> builtins.set[builtins.int]: ...
def write_mps_file(instance: bytes, path: builtins.str) -> None: ...
