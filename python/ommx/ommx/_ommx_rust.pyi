# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import os
import pathlib
import typing

class ArtifactArchive:
    image_name: typing.Optional[str]
    annotations: dict[str, str]
    layers: list[Descriptor]
    @staticmethod
    def from_oci_archive(path: str | os.PathLike | pathlib.Path) -> ArtifactArchive: ...
    def get_blob(self, digest: str) -> bytes: ...
    def push(self) -> None: ...

class ArtifactArchiveBuilder:
    @staticmethod
    def new_unnamed(
        path: str | os.PathLike | pathlib.Path,
    ) -> ArtifactArchiveBuilder: ...
    @staticmethod
    def new(
        path: str | os.PathLike | pathlib.Path, image_name: str
    ) -> ArtifactArchiveBuilder: ...
    @staticmethod
    def temp() -> ArtifactArchiveBuilder: ...
    def add_layer(
        self, media_type: str, blob: bytes, annotations: typing.Mapping[str, str]
    ) -> Descriptor: ...
    def add_annotation(self, key: str, value: str) -> None: ...
    def build(self) -> ArtifactArchive: ...

class ArtifactDir:
    image_name: typing.Optional[str]
    annotations: dict[str, str]
    layers: list[Descriptor]
    @staticmethod
    def from_image_name(image_name: str) -> ArtifactDir: ...
    @staticmethod
    def from_oci_dir(path: str | os.PathLike | pathlib.Path) -> ArtifactDir: ...
    def get_blob(self, digest: str) -> bytes: ...
    def push(self) -> None: ...

class ArtifactDirBuilder:
    @staticmethod
    def new(image_name: str) -> ArtifactDirBuilder: ...
    @staticmethod
    def for_github(org: str, repo: str, name: str, tag: str) -> ArtifactDirBuilder: ...
    def add_layer(
        self, media_type: str, blob: bytes, annotations: typing.Mapping[str, str]
    ) -> Descriptor: ...
    def add_annotation(self, key: str, value: str) -> None: ...
    def build(self) -> ArtifactDir: ...

class Descriptor:
    r"""
    Descriptor of blob in artifact
    """

    digest: str
    size: int
    media_type: str
    annotations: dict[str, str]
    user_annotations: dict[str, str]
    def to_dict(self) -> dict: ...
    @staticmethod
    def from_dict(dict: dict) -> Descriptor: ...
    def to_json(self) -> str: ...
    @staticmethod
    def from_json(json: str) -> Descriptor: ...
    def __str__(self) -> str: ...
    def __eq__(self, rhs: typing.Any) -> bool: ...

class Function:
    @staticmethod
    def from_scalar(scalar: float) -> Function: ...
    @staticmethod
    def from_linear(linear: Linear) -> Function: ...
    @staticmethod
    def from_quadratic(quadratic: Quadratic) -> Function: ...
    @staticmethod
    def from_polynomial(polynomial: Polynomial) -> Function: ...
    @staticmethod
    def decode(bytes: bytes) -> Function: ...
    def encode(self) -> bytes: ...
    def almost_equal(self, other: Function, atol: float) -> bool: ...
    def __add__(self, rhs: Function) -> Function: ...
    def __sub__(self, rhs: Function) -> Function: ...
    def __mul__(self, rhs: Function) -> Function: ...

class Linear:
    @staticmethod
    def decode(bytes: bytes) -> Linear: ...
    def encode(self) -> bytes: ...
    def almost_equal(self, other: Linear, atol: float) -> bool: ...
    def __add__(self, rhs: Linear) -> Linear: ...
    def __sub__(self, rhs: Linear) -> Linear: ...
    def __mul__(self, rhs: Linear) -> Quadratic: ...

class Polynomial:
    @staticmethod
    def decode(bytes: bytes) -> Polynomial: ...
    def encode(self) -> bytes: ...
    def almost_equal(self, other: Polynomial, atol: float) -> bool: ...
    def __add__(self, rhs: Polynomial) -> Polynomial: ...
    def __sub__(self, rhs: Polynomial) -> Polynomial: ...
    def __mul__(self, rhs: Polynomial) -> Polynomial: ...

class Quadratic:
    @staticmethod
    def decode(bytes: bytes) -> Quadratic: ...
    def encode(self) -> bytes: ...
    def almost_equal(self, other: Quadratic, atol: float) -> bool: ...
    def __add__(self, rhs: Quadratic) -> Quadratic: ...
    def __sub__(self, rhs: Quadratic) -> Quadratic: ...
    def __mul__(self, rhs: Quadratic) -> Polynomial: ...

def evaluate_constraint(function: bytes, state: bytes) -> tuple[bytes, set[int]]: ...
def evaluate_function(function: bytes, state: bytes) -> tuple[float, set[int]]: ...
def evaluate_instance(function: bytes, state: bytes) -> tuple[bytes, set[int]]: ...
def evaluate_linear(function: bytes, state: bytes) -> tuple[float, set[int]]: ...
def evaluate_polynomial(function: bytes, state: bytes) -> tuple[float, set[int]]: ...
def evaluate_quadratic(function: bytes, state: bytes) -> tuple[float, set[int]]: ...
def used_decision_variable_ids(function: bytes) -> set[int]: ...
